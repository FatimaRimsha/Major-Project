Music. You. All right this is is 50 this is week two wherein we will ultimately learn how to use memory but we thought we'd first begin with a bit of story time and in fact allow me to walk over to our brave volunteers who have joined us already first here on my left we have who hi i'm a shay i'm a first year in matthews and i'm planning on concentrating in chemical and physical biology and is wonderful welcome and let me have you hang on to the microphone first because we've asked a shay. To tell us a short story so in your envelope you have the beginnings of a story if you wouldn't mind reading it aloud and as she reads this allow us to give us some thought as to what level a shay reads at so to speak all right it's a long one get ready one fish two fish red fish blue fish all right very well done what grade level would you say she reads at if you think back to your middle school grade school when maybe teachers said you read at this level or maybe this level or this one here. It's of no offence taken yet sorry first grade of so first grade is just about right and in fact according to one algorithm this text here one fish two fish red fish blue fish would indeed be considered to actually be first grade or just before first grade so let's and why is that though why did you say first grade it's very basic but what is it about these words that are very basic do you want to identify yourself sure they're all one syllable. Very simple like color and stuff like that spot on so like they're very short words they're very short sentences and you would expect that sort of a younger person all right let's go ahead and hand the mic to your your next volunteer here if you'd like to introduce yourself yes hi i'm ethan i'm a first year in canada and i will be concentrating in economics wonderful and in your folder we have another story to share congratulations today is your day you're off to great places you're off in a way so this text might sound familiar particularly on the heels of high school. School perhaps what grade level might he be reading at so maybe fifth grade and why fifth grade of yeah so a little more complicated like the words we've got some more punctuation we have an apostrophe we have longer sentences and indeed according to one algorithm not quite fifth grade but we would adjudicate your reading level to be third but let's see if we can't do one final flourish here if you'd like to introduce yourself and your story. I'm also a first year i'm in weld and i'm planning on concentrating in biomedical engineering welcome and your tale it was a bright cold day in april and the clocks were striking 13 winston smith his chin nuzzled into his breast in an effort to escape the vile wind slipped quickly through the glass doors of victory mansions though not quickly enough to prevent a swirl of gritty dust from entering along with him all right so escalated quickly and someone's guess at this reading level. 1984 is indeed the text in question and in what grade did you perhaps read that book so i'm hearing eighth i'm hearing 10th so indeed 10th grade is what a certain algorithm would actually adjudicate that reading level to be at and consider now the heuristics so we started with very small words very small sentences very easy words and then things sort of escalated into more interesting more sophisticated english more interesting sentence construction and the like so i bet if we could somehow capture those characteristics. Of text the length of the words and the lengths of the sentences and the position of the punctuation i dare say even using week one material and today week two material we'll be able to actually write code and implement an algorithm like that that can take these spoken words put them to paper and actually analyse roughly what that reading level might be so that's just a teaser of what lies ahead for now allow us to thank our volunteers each of whom gets a wonderful parting gift here to read at home all right and thank you all. So with that said there's another domain that we'll explore this week and indeed what you'll find in the coming weeks is that beyond just focusing on some of the fundamentals and the basics like we've really done the past couple of weeks talking about loops and conditionals and boolean expressions really building blocks or puzzle pieces that we can assemble together we're going to increasingly start talking about applications of these ideas which after all is why any field is perhaps important and applicable so here for instance we'll consider not only reading levels today and in turn. And problem set two this week but also the world of cryptography which is the art the science of scrambling encrypting information and ciphering it in such a way that you can send a message securely through the internet through the air through any medium even though someone might intercept it ideally thanks to cryptography they shouldn't be able to decrypt it or actually determine what it there says so for instance if you were to receive a message like this at first glance it's indeed a bit cryptic. Maybe but by teens end we'll have decrypted even this message for you so up until now though we've had some sort of conceptual training wheels on and i gave us this picture last week when we introduced the tool make by which you can make programs out of your source code because you need to turn that source code into machine code the zeros and ones and in the middle here was this thing called a compiler but it really has been kind of an abstraction for us and we've sort of had these metaphorical and sort of physical training wheels here in the sense that we haven't. Really needed to care like what the compiler is doing how it works and so forth but today what we thought we'd do is peel back a bit of that layer so that even though after today you'll continue to be able to use commands like make and sort of return to the beautiful abstraction that is not caring about some of these lower level details we'll offer you a glimpse of how some of these things work because so that inevitably when something goes wrong you've got some bug you're having some problem you'll have a bottom up understanding of what it could actually be and indeed these basics. You'll find will very often help you troubleshoot problems and really solve problems more generally so here for instance is the code that we keep coming back to and this code here is the simplest of a programs that just says hello world this is the source code this we claimed was the corresponding machine code and it was that program called a compiler that converted one into the other but let's dive a little more deeply this week into what we mean by compiling code like what is happening so that by days end nothing really feels like magic. Anymore it's not just that it goes from source code to machine code and that's that you understand like what's actually being done for you and frankly what other humans have done over the decades to make make as beautifully abstract and as simple as it now might seem to be so here are the couple of commands that you've been in the habit of running when you want to first compile your code and then execute your code but it turns out that make is actually running another command for you the first of several white lies will tell in the course is that make itself. Is not a compiler per be it's actually a program that automatically runs a compiler for you and by that i mean this let me go over to is code here and let me create our familiar hello a program and i'm going to go ahead and do include standard to hint main void and inside of the curly braces print hello world backslash a semicolon so that's the code that we keep writing again and again and up until now if i wanted to compile that i would do. Make hello dot slash hello and voila now my program is made and it actually executes but what's actually going on underneath the hood there is that make is running an actual compiler for you and the reveal today is that the compiler we have been using is something called clang for a language and this is just another program whose purpose in life is actually to do the conversion of source code to machine code but it turns out that clang by itself can be used very simply like you see here. Dot a but it doesn't behave nearly as user friendly as you might like so in particular let me go ahead and do this i'm going to go ahead and remove my compiled program by running pm for remove which i alluded to briefly last time and then i'm going to say a for yes remove that regular file and if i go ahead now and run just clang of hello dot a and hit enter it seems to be successful at least in so far as there's no error messages but if i try to do dot slash hello enter there is no such file or directory. Called hello that is because by default clang somewhat goofy just outputs a file name called a out like why a well it's sort of a simple name a out technically for assembler output but this just means this is the default file name that clangs going to give us so of it turns out i can do a out enter and voila that now is my program but that's just kind of a stupid name for a program it's not very user friendly it's certainly not an icon you would want to put on peoples desktops or phones so how can we do better. Well it turns out with clang we can configure it using what we'll call command line arguments and command line arguments are actually something we've been using thus far we just didn't slap this word on it but command line arguments are additional words or shorthand notation that you typed at your command prompt that somehow modify the behavior of a program and you can perhaps guess where this is going it turns out that if i actually want to create a program called hello not a out which is the default. I can actually do this clang space dash lowercase of space hello or whatever i want to call the thing space hello dot a and now if i hit enter nothing seems to happen but now if i do dot slash hello and enter now i've actually got that program so why is make useful well it just saves us the trouble of having to type out this longer line of command any time we actually want to compile the code but in fact it gets even worse than that with commands that. Like clang or compilers in general because consider this code here not just the version of hello world but maybe the second version wherein last week i started to get user input by adding the cs50 library using get string and then saying hello david well if i go back to is code and i modify this program to be that same one so let me go ahead and include cs50 hat the top let me get rid of this simple print line and instead give myself a string called name equals. Get underscore string what's your name just like we did in scratch then i can do print quote unquote hello comma and previously i typed world i obviously don't want to type david because i want it to be dynamic what did i type last week for as a placeholder so yeah just not commands but percent a so percent a in this case which is a placeholder for any such string then i can still do my new line close quote comma and then i can substitute in something like the value of the name there. All right so if i go ahead now and compile this now last week i could just do make hello and i'm on my way it worked just fine but if i instead do clang manually it turns out that this is not going to be sufficient now clang dash of hello space hello dot a the exact same thing i typed a moment ago but i think i'm going to see some errors so what's this error hinting at here well at the very bottom it's a bit arcane with its output and much of this you can ignore but there are some certain key words. What's the first maybe key word you recognize in these three lines of erroneous output so it mentions main that's not that much of a clue because that's the only thing i wrote so far second line though get string there's some issue with an undefined reference to get string now why might that be i did include cs50 a but that's apparently not enough to teach the compiler about get string well it turns out that if you're using a third party library one that doesn't necessarily come with cs50. A the language something like is 50s it turns out that you additionally have to tell the compiler that you want to use that library and not just by including the header file but by an additional command as well so when you run clang you want to provide an additional rather command line argument literally dash a for library which is a term i used last week is 50 a library is just code that someone else wrote that you want to use in your project so if i really want to compile this version that uses the is 50 library i can still do that. Clang dash of hello hello dot a but before i finish my thought i need to tell the compiler to link so to speak in the library cs50 and now i hit enter the error message goes away i can do dot slash hello i can type in my name and voila we're back to week one and this is why suffice it to say we introduce make which is not a cs50 thing this is a popular tool that people in the real world use to automate these kinds of processes so unbeknownst to you make has been using the dash of for you. Make unbeknownst to you has been using dash a cs50 for you just because it makes our lives easier but today we thought we would deliberately sort of peel back this layer so we at least understand what's going on behind this abstraction that is make itself and compiling more generally so let me propose that compiling itself is not quite what we've described it to be compiling is like this catch all phrase that apparently i claim goes from source code to machine code but if we really want to get pedantic which we'll do briefly. But this is not a sign of things to come because this too will we abstract away compiling is just one of four steps that are involved in turning source code that you and i write into those zeros and ones but through an understanding of these four steps today you'll hopefully better understand how to troubleshoot issues like that and just kind of know what's happening because it's not in fact magic it's just the result of years of humans developing these four steps here so when you run make what's happening or in turn when you run client. Four different things are happening and the first one is called reprocessing so what is this all about well let's consider this code here and this codes a little bit interesting insofar as it's one of the more complicated examples from last week and you'll notice for instance that i had include standard it at the top so i could use print i had main down here whose purpose in life was just to meow three times and then recall we made our own meow function just like we did in week zero with scratch that just printed out quote unquote. Quote meow but i also included this line here which we called what this was a prototype and why did i have to include it there or equivalently what would happen if i didn't include a prototype up at the top there yeah exactly if i didn't include it up here the program when trying to compile main would not know what meow is because it's not defined until later. Of like a little hint of what is to come alternatively we could just move this whole thing up at the top of the file but i claim that that just devolves into a big mess eventually once you have many different functions like you can't realistically put them all at the top to solve this problem so these prototypes solve that problem so nothing new here just a reminder of what motivated this one line of prototype now let's consider this simpler program which is just the one we wrote most recently in is code this program prompts the human for their name and then says hello to that. But it has two includes at the top of the file and in fact any line of a that starts with this hash symbol is what we'll call now a preprocessed directive it's not really a word you need to remember in your vocabulary but it is a little bit different from most every other line because it starts with that hash that's sort of a special symbol in a and what this means is the following this very first line cs50 his indeed a file that i and cs50 staff wrote and we installed somewhere in is code 4. For you somewhere in the cloud and i've claimed you need to use this header file in order to use get string so just logically what is probably inside of cs50 a yeah super close so the function called get string that does the getting of a string but it's not quite as much as the function itself. It's actually a little bit less than that but you're on the right track what is inside of cs50 a presumably just a what just a prototype for which function get string so admittedly there's some other stuff in there too but the important line for today is discussion is that inside of cs50 his indeed one line of code that defines what the return value what the name is and what the arguments if any are to get string. And so what happens effectively when you compile your code step one is this reprocessing line and essentially there is some code that someone else wrote inside of the clang compiler that looks for a line that starts with hash include and when it sees that it goes and finds this file and effectively copies and pastes the contents of that file right there into your code so that you don't have to go find the file copy and paste it and make a mess of your own code so in particular it's effectively as though you're copying and pasting the protocol. Of get string to the very top of your file thereby teaching the compiler that it exists by that same logic what is probably in standard i of doth the prototype for for print of and indeed exactly that so this line effectively gets replaced with the equivalent of the prototype for print of which for today is purposes is a bit more complicated so let me wave my hand at the dot dot dot just because it takes a variable number of arguments depending on how many placeholders or format. That code you have but effectively that too is what's happening so the preprocessed step step one of four just does that find and replace if you will now there's some again some other stuff in that file and this too is kind of a white lie print probably has its own file because that's a really big library but the essence of it is exactly this so reprocessing converts all of those hash include lines to whatever the underlying prototypes are within the file plus some other stuff now compiling we use it as this catch all phrase. It has a very specific meaning that's worth knowing about even though after today you can go back to using compiling as the sort of catch all phrase so when you've got this same code here after the are processing step has happened so this is essentially happening in the computers memory it's not changing your hello a file permanently or anything like that this code gets quote unquote compiled into something that looks more like this and this is a scarier language that we won't spend time on in this. Particular class this is what's known as assembly language and back in the day before there was a humans wrote this to program their computers similarly before there was assembly code back in the day humans very initially used what instead so zeros and ones like they actually wrote the machine code painfully be it in code or be it in punch cards like physical objects or the like so again these are sort of abstractions but we're rewinding for today in time but what this compiler for a is doing is. Converting a into this other language called assembly language and even though this looks very esoteric there's at least some juicy things in here if i highlight get string is mentioned in this code print is mentioned in this code and even some of these keywords here that are spelled a bit weirdly this relates to subtracting and moving something in memory and calling a function calling a function so there's some semantics that are probably somewhat familiar even though this is not code we ourselves will write but unfortunately this is not yet machine code. That's where step three comes in so step three of this four step process is technically called assembling and assembling just takes that assembly code and converts it thankfully to the thing we do care about the zeros and ones so assembling takes assembly code converts it to zeros and ones as an aside and i alluded to this earlier the reason that clang names its files a out by default assembler output is kind of a side effect of that being one of the steps in this. This process dealing with assembly language and its subsequent output all right so here are some zeros and ones but unfortunately there's still that fourth and final step which is a word that i also used earlier namely linking so let me take a step back and look at this code here and even though this code is exactly as i wrote in is code in hello a so no copying and pasting no prototypes have been plugged in here this is my code technically there's three different files involved in compiling even something relatively simple like this. There's obviously this thing itself hello dot a which i wrote there's apparently is 50 doth and there's apparently standard to doth but technically and you don't have to know this file name per be somewhere else on the computers hard drive so to speak is a is 50 dot a file which actually contains the staffs implementation of get string and get int and get flow and all of those other functions somewhere on the servers hard drive is standard to dot a that implements print of and all. All of these other functions as well so the dot a is just inferred from the doth here you don't ever mention the dot a file but someone else wrote those files someone else stored them in the server for you cs50 staff in this case so technically even when compiling a relatively short program like this you're really combining three files at least at the end of the day and i'll write them from left to right hello dot a which i wrote which cs50 dot a which the staff wrote and then standard to. Dot a as well so somewhere there's these three files and clang our compiler needs to compile each of these into the corresponding zeros and ones lastly this is not yet sufficient because these zeros and ones haven't been linked together i mean i deliberately left a gap here to imply that these are three separately compiled files so that fourth and final step called linking takes all of these zeros and ones and an intelligent way combines them into. To just one final file named hello named a dot out whatever the file name is of choice so what you and i for the past week have just been calling compiling and that's what a typical normal person will use henceforth to describe this whole process technically there's these four different steps underneath the hood each of which is sort of a representative of an evolution of technology over the years and nowadays if we fast forward a few weeks in class when we start talking about python which. Another more modern language that too is going to be conceptually even higher level even though underneath the hood there's going to be some lower level principles at work so any questions on just terminology or these processes known as compiling yeah sure compiling if i rewind is the process of taking your source code which looks. Like this recall whoops this and converting it into assembly code so reprocessing just converts all of those hash include lines and a few others to their equivalents so that's step one compiling converts the a code into the underlying assembly code the assembling step step three converts the assembly code to zeros and ones and then the fourth step linking combines all of the zeros and ones from the one the two the three or more files that are involved in your project. And links them all together for you magically but at the end of the day all of this is sort of happening automatically for you if i jump now to the end here whereby just by running make which in turn runs clang for you all of this is abstracted away but the key here is that even with these commands that we've been running be it the make command or the clang command everything should be explainable what you are typing at the prompt ultimately. Has a purpose so any questions then on what we've just now called compiling even though it's only when you take another is course that you might spend more time on assembly language or these lower level details yeah a good question are there other types of compilers yes back when i took cs50 i used a popular compiler called acc the gnu compiler collection which still exists actually in the. Code space that you're using for is 50 clang is somewhat more recent it's gaining popularity and frankly we use it in large part because it's error messages are slightly more user friendly you might not believe us because if you encountered some errors with your code this past week they were probably just as arcane as the error message i saw but it's better than it was some years ago and there's alternatives to compiling too but more on that when we get to python as well other questions all right well what are the implications of the fact that we're going from. Source code to machine code well it stands to reason that if you can compile code maybe you can recompile it that is going the reverse direction go from zeros and ones to actual source code now that would be handy if you want to go in as a programmer and like change something in a program that you or someone else already wrote it's maybe not ideal for your intellectual property though if you are the person who wrote that program in the first place if you are microsoft and you wrote microsoft word or excel that people with macs and pcs and phones have been. Installed on their devices it doesn't actually sound very appealing if any old customer can take those zeros and ones and reverse them reverse engineer them so to speak into the original source code because then they can have their own version of microsoft word and make changes to it without really having put in all of the re that might have taken to build the first version thereof but it turns out that reverse engineering so sort of doing things in the opposite direction is easier said than done because there are multiple ways as you've seen already. Implement programs like loops alone you can use for loops while loops even do while loops and so there's other ways there's multiple ways to solve the same problem so even if you try to reverse engineer a program and convert machine code back to source code there's not necessarily going to be an obvious way to do so and the reality is that it ends up being such a mess because you lose the variable names typically you lose the function names typically that what you end up looking at might very well be a code but it's completely. Difficult for you even a good programmer to read and generally the sort of mindset is if you're really good enough to recompile code in that way and read it subsequently even without good variable names good function names good documentation and the like you could probably have just implemented the program in the first place yourself without jumping through those hoops so there's sort of some practicality pushing back on what are otherwise potential threats to say your intellectual property but that's not going to be the case later on in the term when we do get to languages like python to say. Some extent other languages like javascript some of those are actually going to be readable by anyone and if your customers and your friends and your family that actually use your programs so with that said let's introduce now another tool to our toolkit that will hopefully make some of the pain from this past week when you did encounter bugs a little more manageable and indeed part of the process of writing code to this day is debugging it and it is a rare thing to write a program be it in a or any other language and get it 100. Write the first time i mean to this day i still 20 plus years later still write buggy code hopefully a little bit less of it but any time you're adding a new feature any time you're doing something for the first time you're not necessarily going to see all of the possible mistakes so even in industry bugs are omnipresent which is really to say having techniques to debug code that is eliminate bugs is super compelling now just for a bit of history here is admiral grace hopper who was actually in not only the military. But also on the faculty of harvard years ago and worked on a harvard computer called the harvard mark i which is actually on display at the school of engineering and applied sciences if you take a tour over there sometime but also when working on the harvard mark ii she is known for having at least popularized the phrase bug to mean a mistake in a computers program a mistake in a computers code and the etymology of this supposedly is this here logbook wherein she and her colleagues were. Sort of documenting processes being computed on computers that a moth actually got stuck in one of the relays one of the electric relays inside of the very old now computer and someone very cleverly wrote first actual case of bug being found so it wasn't she who actually discovered it but this was a story she was thereafter fond of telling as a famed computer scientist thereafter we now know bugs to be all too familiar when it comes to writing our own code and i thought i would deliberately write some bugging. Code based on some of the programs with which we experimented last week so let me go back over to is code here and let me propose that i do something somewhat simplistic just like this to print out a column of bricks of height three so i'm going into is code and i'm going to deliberately call this program buggy dot a because i intend to do this poorly i'm going to include standard to doth as before int main void as before and in here if i want to print. I'm going to do four int i gets all right i'm still new to programming in my mind here so like i know i'm supposed to start counting at zero of and i want to do this until i count up to three so i'm going to do that and then i plus plus i remember from class in this way and now i might go ahead and print out just a hash mark backslash a which i do want because i want to move this cursor to the next line to make this vertical but of course if you've noticed with your eye already when i do make buggy if you want to make it a little bit more. Compiles of so no typos no syntactical errors but when i run this i'm going to see how many bricks so four in this case now this is meant to be a simplistic example so that we don't spend time trying to figure out what the bug is but rather focus on techniques for actually identifying the bug so finding rather the bug so what's one of the first tools in your toolkit literally one you have already print is your friend and it is a very quick and dirty tool for just seeing what's. Going on inside of the computer when you don't have more sophisticated tools or even the time to use them and so in this case for instance what i'd propose is that i'm obviously seeing four hashes and let me play a little slow here it'd be helpful for me to understand why logically i'm ending up with four even though i'm starting at zero like i remember from class and i'm going up to three as we did in class like i'm just not seeing it in this particular story so what i would commonly do is go into my code and just help me see. What's going on and i might literally write us print of line like i is percent i backslash a comma and then just print out the value of i i just want to see on every iteration what is i what is i what is i just help me see what the computer already knows so let me go ahead and recompile buggy let me rerun buggy and then let me make my terminal window bigger just to make clear what's going on and now it's a little more pedantic now i is zero i get a hash i is one i get a hash. I get a hash wait a minute i is three i get a hash so clearly now it should be maybe more obvious to you especially if the syntax itself is unfamiliar i certainly don't want this last one printing or maybe equivalently i don't want the first one printing so i can fix this in a couple of ways but the solution the most canonical solution is probably to do what with my code to change what to what yeah yeah so change the less than or equal sign to just a. Less than sign so even though this is like counting from 0 to 3 instead of 1 through 3 it's the more typical programmatic way to write code like this and now of course if i do make buggy and i'll increase my terminal window again dot slash buggy now i see what's going on inside of the code now it matches my expectations and so now the bug is gone now of course if i'm submitting this or shipping it i should delete the temporary print and let me disclaim that using print in this way. Just to help you see what's going on is generally a good thing but generally adding a print and a print and a print and a print like it starts to devolve into just trial and error and like you have no idea what's going on so you're just printing out everything let me propose that if you ever find yourself slipping down that hill into just trying this trying this trying this you need a better tool not just doing print and frankly it's annoying to use print because every time you add a print you have to recompile the code rerun the code it's just adding to the. The number of steps so let me propose instead that we do this i'm going to go back into is code here and i'm going to write a different program that actually has a helper function so to speak a second function whose purpose in life is maybe just to print that column for me so i'm going to say this void print column though i could call it anything i want and this function is going to take a argument or a parameter called height which will tell it how many bricks to print how many. I'm going to do the same kind of logic for int i equals 0 i is less than i'm going to make the same mistake again less than or equal to height i plus plus and then inside of this for loop let me go ahead and print out the hash mark so i've made the same mistake but i've made it in the context now of a helper function only because in main what i'd like to do now just to be a little more sophisticated is get int from the user for the height and when i do get that int i want to store in a variable that i'm going to use. But i do need to give that variable a type like last week so i'll say that it's an integer and now lastly i can print underscore column passing in actually i'll call it a just because height is a print column a semicolon of so it's the exact same program except i'm getting user input now so it's not just going to be 3 it's going to be a variable height but i've done something stupid i've done two stupid things so this of course is a very simple thing. Of course it's not supposed to be there so i'll fix that and someone else what else have i done yeah i'm missing the prototype and this is let me reiterate probably the only time where copy paste is of once you've implemented the function you can copy paste its first line at a semicolon so that it teaches the compiler that this function will exist three stupid things of thank you. Good good include is 50 doth and now anyone want to go for four no all right slightly unintended here so let's see make buggy of no syntax errors thanks to you all so the code compiles but of course when i run buggy and i type in something like three manually i'm still going to get one two three four out so let me now introduce a more powerful tool that's generally known as a debugger and within the is code environment that you're using we actually have a command. That makes it a little easier to use this tool but we didn't write the tool itself you are about to see a very graphical a very popular industry standard tool called a debugger but we'll start the debugger using a cs50 specific command called debug50 which just makes it easier with a single command to start the debugger without having to configure a text file with all of your preferred settings and all of that it's just an annoying hoop otherwise to jump through so what i'm going to do is go back to my code here i have already compiled it but just for good measure i'll make buggy again because the debugger. Needs your code to be compiled it's not going to help with syntax errors like the stupid mistakes i just made unintentionally it will help you though with programmatic errors logical errors in your code once your code is running so to run debug 50 i'm going to do this debug 50 space and then the exact same command i would normally run to just run the program itself so dot slash buggy so exact same thing dot slash buggy but i prefix it now with debug 50 when i hit enter a whole bunch of another error. Is going to pop up on the screen which is a good reminder because this will happen to you too invariably it's reminding me that i have to set what's called a breakpoints and as that word suggests it is the point at which you want your code to break not break in the make the situation worse sense but rather where do you want to pause execution break execution like hitting the brakes on a car so the program doesn't run all at once and you can put this any number of places and you might have done this accidentally if you've ever hovered over the gutter of is code the left hand side. Next to your line numbers see the little red dot that appears if i click on any of these lines that's going to set a breakpoints so to speak and i want to break execution at main so i'm just going to click to the left of line 6 in this case that makes it a darker red circle a stop sign of sorts that tells the debugger to pause execution on that line though i could put it elsewhere if i so choose let me go ahead and rerun debug50 slash buggy enter and now a bunch of things are going. It's going to look a little overwhelming perhaps at first glance but there's some useful stuff that just happened so one my code is still here but the line that i set the breakpoints on is rather the first line of actual executable code at or below the breakpoints i set is highlighted in this yellowish green here which says this line of code has not yet been executed we broke at this point but if i click a button this line of code will be executed. Because up until now every a program you write runs as fast as that i want to pump the breaks and pause here but notice a few other aspects of the window here so notice that up here some weirdness there's mentions of variables and we're familiar with these local is a term we'll use this week but there's this variable a which weirdly where did the value 21 912 come from so it turns out in a before you initialize a variable with a value by literally typing the number 3. By using a function like get int it often contains what's called a garbage value more on those in a couple of weeks but a garbage value is you can think of it as like remnants of whatever was in the computers memory before you ran your program and that's a bit of an oversimplification but you cannot trust that a variable will have a certain value in this case if you did not put ones there yourself so for now his sort of nonsensical it's a garbage value it means nothing but once i execute this line it should contain whatever the human types in. Here there's a watch section which is a more sophisticated feature down here is what's called the call stack more on that in the future but what this means for now is that i'm executing the main function not for instance print column so notice up here these are the most useful controls within the interface if i hit this play button it's just going to actually run my program to the end of it without bothering me further however i can actually step over this line of code and execute it or i can step into this line of code and actually poke around the contents of get int. Available on the system so conceptually you can either execute this line or you can dive down conceptually deeper and see what's inside of that function lastly this will let you step out this will allow you to restart the whole process and this will just stop the debugger so these buttons are going to be our friends and the one i'll click first is the first one i described which is step over so step over doesn't mean skip this step it just means execute it but don't bother me by going into the weeds of what is on this specific line. So when i click this button in a moment you'll see that my terminal which is still at the bottom prompts me for a height i'm going to go ahead and type 3 as soon as i hit enter what part of the screen probably will change based on what i've said so a the variable a should hopefully take on the number 3 and i'll probably see a different line of code highlighted probably line 9 next once i'm done executing line 8 so let me go ahead and hit enter and watch the top of the screen. Left of the screen and voila a now has the value three and execution has now paused on line nine because the debugger is allowing me to step through my code line by line now let me go ahead and print out let me go ahead and just say all right i'm done with this let's go ahead and run the rest of the program it clearly got the value three but wait a minute of and at this point it closed the window in which i would have seen the output i would have still seen four hashes so let me actually do this again. Let me go back into debug50 by running the exact same command again it's going to think for a moment it's going to reconfigure the screen i'm going to do the exact same thing i'm going to step over this line but i'd like to actually see what's going on inside of my print column function so this time instead of just saying run to the end and close all the windows on me let me go ahead and step into my print column function so don't step over step into because if i step over and now this is what i meant to show earlier. You can see that it's still printing out four so in fact let me undo this let me just stop the whole thing let me rerun the command a final time so it goes back to where we began before it's going to prompt me again once i step over line eight for a number like three but this time instead of stepping over line nine let's poke around i wrote print column so let's look at print column step by step step into it and watch what happens to the yellow highlight it now jumps logically to the inside of print column. Thereby letting me walk through this code and now i can just step over each of these lines one at a time so stepping over of so what did it do it did that whole narrative that i did verbally last week where it compared i against height it then went inside of the loop when i step over watch what happens in my terminal one hash prints out now line 14 is highlighted again it's comparing per the boolean expression i is it less than or equal to height if so it's going to go ahead and print out the hash. It's going to do this again print out the hash but notice at the top left of the screen height is still the same it's still 3 but what has been changing apparently i on each iteration so the debugger is letting me see what's going on slowly inside of this loop because i keeps getting incremented so if i step over this line now notice that i've now printed 3 so ideally i want this loop to end but if i click step over once more notice that the value of i at top left is 3. But 3 is less than or equal to height of now i get it if i play along here now i see why less than or equals to mathematically is clearly incorrect and as soon as that light bulb goes off you can just sort of bail out click the red stop button to turn the debugger off go back in fix your code and voila recompile run it and you're back in business so the takeaways here really are just what tools now exist print is your friend but only for quick and dirty sort of debugging techniques. Into the habit now of using debug 50 and in turn is codes debugger you will invariably not take this advice say for problem set to as you first begin because you know it's going to feel easier and quicker just to use print of just to use print of just to use print of and the problem with that logic is that you begin to build up like technical debt so to speak where you really should have learned it earlier you really should have learned it earlier you really should have learned it earlier at which point you end up spending more time wasted using print of and doing things manually. Then if you had just spent 10 minutes 30 minutes just learning the user interface and the buttons of a proper debugger so please take that advice because it will save you significant amounts of time over time questions on print or debugging in this way any questions on this no of so let me give you a third and final technique for debugging which has kind of been lovely. Looming over us here for some time so there is actually this technique known as rubber duck debugging and in the absence of a roommate who's taking cs50 or who has taken cs50 or knows how to program in the absence of having a of or to or a sitting next to you in the absence of having a family member available to ask questions of if you have simply an inanimate object on your desk goes the tradition just talk to that inanimate object better yet if it's an adorable rubber duck in this way and the idea of rubber duck debugging. Is that simply by verbalizing literally out loud to this inanimate object probably with the door closed and no one knowing that you're talking to this rubber duck you invariably end up hearing any illogic in your own thoughts at which point the proverbial light bulb tends to go off and you're like of i'm an idiot it's supposed to be less than not less than or equal to so literally just explaining to a duck or any inanimate object what's going on in your code will quite frequently just help you see in your minds eye. What it is you've been doing wrong so rubber duck debugging is indeed a very effective technique even if you don't happen to have a small or large rubber duck of course you're also welcome to use the cs50 duck who lives at cs50 a and also within a pane in is code at cs50 de you can ask the cs50 duck about concepts you don't understand or you can even copy paste certain lines of code with which you might be having trouble and ask the duck for its own advice all right so with those tools and our tools. Toolkit let me propose now that we do that we introduce now a few lower level features of a itself and better understand how we can start solving some of those problems like the readability of text or the encryption of data these were our so called types last week when we introduced at least a subset of them or used them just to store data in a certain format so to speak like in week zero we said that everything at the end of the day is just zeros and ones binary and i claimed sort of conceptually that. How a computer knows if a set of bits is a number versus a letter versus a color or sound or an image or video is just context dependent like you are using photo shop or using microsoft word or something else but last week we saw a little more precisely that it's not quite as broad strokes as that it's more about what the programmer has told the software is being stored in a given variable is it an integer is it a char character is it a whole string is it a longer. Integer or the like so you now have this control the catch though recall though is that each of these types has only finite amount of space allocated to it so for instance an integer is typically four bytes and four bytes is 32 bits because it's eight times four 32 bits we claimed is roughly four billion but if you want to represent negative and positive numbers the biggest integer you can store is like two billion now that's really big for a lot of applications but years ago facebook for instance was rooming. To be using integers when they had fewer users but now that they have billions of users three plus billion users an integer is no longer big enough for the facebook the googles the microsoft and so forth of the world so we also have longs which use twice as money bytes but exponentially bigger range of values meanwhile a book interestingly is a byte which is kind of bad design in what sense. It should be bad design it's only it should only be to one bit rather because a zero or one should suffice turns out it's just easier to use a whole bite even though we're wasting seven of those bits but bulls are represented nonetheless with one bite chars are going to be one bite floats tend to be four bites doubles tend to be eight bites some of this is system dependent but nowadays on modern computers this tends to be a useful rule of thumb the only one i can't commit to here is a string because a string recall is a sequence of text and maybe it has no character. One character to 10 100 so it's a variable number of bytes presumably where each bite represents a given character so with that said how do we get from an actual computer to information being represented therein well let me remind us that this is what's inside of our max pcs phones even though this isn't a scale and it might not be the same shape this is memory random access memory and on these black chips on the circuit board here are the bites that we keep talking about in fact let's go ahead and do that. Zoom in on one of these chips kind of fill the screen here and just for artists depictions sake let me propose that if you've got i don't know a megabyte a gigabyte like a lot of bytes packed into this chip nowadays it stands to reason that no matter how many of them you have we could just number them from top to bottom and we could say that this is byte one or you know what this is byte zero one two three and this is maybe byte one billion or whatever it is so you can think of memory as having addresses or just locations numeric. That identify each of those bytes individually why a byte individual bits are not that useful so eight again one byte tends to be the de fact standard let me abstract so for instance if you're storing just a single character a char it might be stored literally in this top left corner so to speak of the chip of memory if you're storing maybe an integer four bytes it might take up that many bytes if you're storing a long it might take up that many bytes instead now we don't have to dwell on the potential. Particulars of the circuit board and these traces and all the connections so let me just kind of abstract this away and claim that what your computers memory really is it's just kind of this canvas i mean kind of in the photo shop sense if you've ever made pictures it's just a grid of pixels up down left right that's really all your memory is it's this canvas that you can manipulate the bits on to store numbers anywhere you want in the computers memory so in fact let's zoom in here and let's consider how your computer is actually storing information. Using just these bites at the end of the day no matter how sophisticated your mac your pc your phone is like this is all it has access to for storing information it's a canvas of bites and what you do with this now really invites design decisions so let's consider this here is an excerpt from a program wherein maybe i'm prompting the user for three scores like three test scores exam scores something like that and the purpose in life of this program is maybe to average those three scores together if you want to get a sense of where you stand. So we can certainly whip up some code like this and in just a moment let me go ahead and flip over to is code here and i'll write up a new program called scores a and in this let me go ahead and first include standard to hint main void at the top and in here let me go ahead and assume that it's not been the greatest semester so my first score which i'll call score one was a 72 my second score was a 73 but my third score was a 72. Score 3 was like a 33 now you might remember these numbers in another context they might spell a message but in this case it's just integers it's just numbers because i'm telling the computer to treat these as its now if i want to figure out what my average is i can do a bit of match so let me just print out that my average is and i don't want to shortchange myself i'm not going to use percent i because i don't want to lose even anything after the decimal point so well you're going to use a float instead and my average i claim will be. Score one plus score two plus score three divided by three semicolon with parentheses because just like grade school match like order of operations i parenthesized the numerator so i can divide the whole thing by three but i have screwed up already i am going to shortchange myself and not give myself as high a grade as i deserve but this ones subtle what have i done wrong yeah i might want to cast these scores to floats right. Is if you do integral match divide an integer or the sum of an integers some integers by an integer it's going to be an integer as the result so it's going to throw away anything after the decimal point even if it's something 0 1 something 0 5 something 0 9 that fraction is going to be thrown away there's a bunch of ways to fix this i could just use floats or doubles for all of these i could cast score one score two or score three as you proposed frankly the simplest way is just change the denominator because so long as i've got. One float involved in the match this will sort of promote the whole arithmetic expression to being floating point match instead of integer match so let me go ahead now and do make scores enter so far so good dot slash scores and my average seems to be not great but 59 3333 so in the third but i would have lost that third if i hadn't used a float in this particular way well let's consider now what's actually going on inside of the computer when i store these three variables so back to the grid here. My canvas of memory doesn't really matter where things end up i might put it here i might put it there the computer makes these decisions but for the artists sake i'm going to put it at the top left hand corner here so score one is containing the integer 72 why is it taking up four squares though because it's an integer and on this system an integer is four bytes so i've drawn it to scale if you will score two is the number 73. It also takes four bytes by coincidence but also by convention it will likely end up next to the first integer in memory because i've only got three variables going on anyway so the computer quite likely will store them back to back to back and indeed by that logic score 3 containing the number 33 is going to fill in this space here we'll consider down the road what happens if things get fragmented something's here something's here something's here but for now we can assume that this is probably contiguous though not necessarily so. So that's pretty straightforward but what's really going on well these are just bytes of memory that is bits of memory times 8 and so what's really going on is this pattern of 0's and 1's is being stored to represent 72 this pattern of 0's and 1's is being stored to represent 73 and similarly 33 but that's a very low level detail that we don't really care about so we'll generally just think about these as numbers like 72 73 33 all right so if we go back to the actual cut. Code though here i wonder if this is the best idea these three lines of code are correct i got my 59 and a third for my average which i claim is correct but code wise this should maybe rub you the wrong way even if you hadn't programmed before cs50 why might this not be the best approach to storing things like scores in a program how might this get us in trouble yeah. Yeah it's not the best because you have to use a whole bunch of different variables for each score they're almost identically named though but just imagine in almost any question involving the design of your code what happens as a the number of things involved gets larger am i really going to start writing code that has score 4 score 5 score 6 score 10 score 20 i mean your codes just going to look like this mess of mostly copy paste except that the number at the end of the variable. Changing like that should make you cringe a little bit because it's not going to end well eventually and typographical errors are going to get in the way most likely because we'll make mistakes so how can we do a little bit better than that well let me propose that we introduce what we're going to now call an array an array is a sequence of values back to back to back in memory so an array is just a chunk of memory storing values back to back to back so no gaps no fragmentation from. Left to right top to bottom just as i already drew but these arrays in cat least are going to give a slightly new syntax that addresses exactly your concern so here instead is i would propose how you define a one variable not three one variable called scores plural each of whose values is going to be an int and you want three integers tucked away in that variable so now i can sort of plurality the name of my variable because by using square brackets. The number three i'm telling the compiler give me enough room for not one not two but three integers in total and the computer is going to do me a favor by storing them back to back to back in the computers memory now assigning values to these variables is almost the same but the syntax looks like this to assign the first value i do scores bracket zero equals whatever 72 scores bracket one equals 73 scores bracket two equals 33 and it's square brackets consistently. And notice this is a feature or a downside of a we very frequently use the same syntax for slightly different ideas this first line tells the computer give me an array of size 3 these next three lines mean go into this array at location 0 and put this value there location 1 put this value there location 2 put this value there so same syntax but different meaning depending on the context here but the equal sign indeed means that this is assignment from right to left just like last week. So what does this mean in the computers memory well in this case here we now have a slightly different way of doing this and actually let me do it first in code let me go back to is code here and let me propose that instead of having these three separate variables let me give myself an int scores variable of size 3 and then do scores bracket 0 equals 72 scores bracket 1 equals 73 scores bracket 2 equals 72. And now i have to change this syntax slightly but same idea scores bracket zero scores bracket one and lastly scores bracket two so a couple of key details i started counting at zero why that's just the way it is with arrays you must start counting at zero unless you want to waste one of those spaces and what you definitely don't want to do is go into scores bracket three because i only ask the computer for three integers if i blind the computer. You're going too far you're going beyond the end of the chunk of memory and bad things will often happen so we won't do that just yet but for now 0 1 and 2 are the first second and third locations so if i recompile this code so make scores seems of dot slash scores and i get the exact same answer there but let me make it more dynamic because this is a little stupid that i'm compiling a program with my scores hard coded what if i have a fourth exam tomorrow or something like that so let's make it more dynamic. Dynamic and they think the syntax will start to make a little more sense let's go ahead and use get int and ask the user for a score let's go ahead and get int and ask the user for another score let's go ahead and get int and ask the user for a third score now storing the return values in each of those variables if i now do make scores darn it mistake similar to one i've made before but we didn't see the error message last time what did i do wrong yeah. Of what did i do wrong how about over here yeah so i'm missing the cs50 header file so how do you know that well implicit declaration of function get int so it just doesn't know what get int is well who does know what get int is the cs50 library that should be your first instinct all right let me go to the top here and let me go ahead and squeeze in the cs50 library like this now let me clear my terminal make scores again we're back in business and notice i don't need to do dash a cs50 anymore. Make is doing that for me for clang but we don't even see clang being executed but it is being executed underneath the hood so to speak all right so dot slash scores here we go 72 73 33 mathis still the same but now the program is more interactive now this too hopefully should rub you the wrong way this is correct i would claim but bad design still sort of reeks of week zero inefficiencies yeah. Of so i could ask the human how many scores do you want to input let's come back to that but i think even in this construct what better could i do use a loop right because i'm literally doing the same thing again and again and notice this number is just changing slightly i would think that a little plus plus could help there get in score get in score get in score that's the exact same thing so a loop is a perfect solution here so let me go over into this code here and i can still for now do. Declare it to be of size three but i think i could do something like this four int i gets zero i is less than three so i'm not going to make the same buggy mistake as i made earlier i plus plus inside of the loop now i can do scores bracket i and now arrays are getting really interesting because you can use and reuse them but dynamically go to a specific location equals get int quote unquote score now i can type that phrase just once and this loop ultimately will do the same thing. But it's getting better the code is getting better designed because it's more compact and i'm not repeating myself 72 73 33 still works the same but we're iteratively improving the code here now how else there's one design flaw here that i still don't love it's a little more subtle any observations interesting so instead of dividing by three. Maybe i should divide it by their array size which at the moment is technically still 3 but i do concur that that is worrisome because they could get out of sync but there's something else that still isn't quite right yeah i'm of moving to this zero indexed model so this is a new term of art to index into an array means to go to a specific location so here i'm indexing into location i. But i is going to start at zero and then one and then two i'm actually of with that even though in common day life we would say score one score two scores three as a programmer i just have to get into the habit of saying score zero score one score two now but something else yeah i could also compute the average in a loop because indeed this is kind of only solving the problem halfway i'm gathering the information in the loop but then i'm manually writing it all out so it does feel like there should be a problem. A better solution here but let me also identify one other issue i really don't like and this is indeed subtle i've got three here i've got three here and i essentially have three here albeit a floating point version this is just ripe for me making a mistake eventually and changing one of those values but not the other two so how might i fix this i might at least do something like this i could say integer maybe a for scores i'll set that equal to three i could then use a here. I could use a here i could use a here but that's a step backwards because i don't want an int because i'm going to run into the same match issue as before but i could convert it that is cast it to a float and we did that briefly last week but there's one other thing i could do here that we did introduce last week this is better because i don't have a magic number kind of floating around in multiple places yeah if i really want to be proper i should probably say this should be a constant integer why because i don't want to accidentally. I don't want to be collaborating with a colleague and they foolishly change it on me this just sends a stronger signal to the compiler do not let the humans change this value and now just to point out one other feature of a if you have a number like this like the number three i've deliberately capitalized this variable name really for the first time anytime you have a constant it tends to be a convention to capitalize it just to draw your attention to it it doesn't mean anything technically capitalizing a variable does nothing to it but it draws attention to it. Visually to it to the human so if you declare something as a constant it's commonplace to capitalize it just because moreover if you have a constant that you might want to occasionally modify maybe next semester when there's four exams or five exams instead of three it actually is of sometimes to define what might be called a global variable a variable that is not inside of curly braces it's literally at the top of the file outside of main and despite what i said about scope last week a. Global variable like this on line four will be in scope to every function in this file so it's actually a way of sharing a variable across multiple functions which is generally fine if you're using a constant if you intend to change it there's probably a better way than actually using a global variable but this is just in contrast to what i previously did which i would call by contrast a local variable but again i'm just trying to reduce the probability of making. Mistakes somewhere in the code and i do agree i don't like that i'm still adding all of these scores manually even though clearly i had a loop a moment ago but for now let's at least consider what's been going on inside of the computers memory so with this array i now have not three variables score one score two score three i have one variable an array variable called scores plural and if i want to access the first element it's scores bracket zero if i want to access the second element it's scores bracket. If i want access to the third element it scores bracket two if i were to make a mistake and do scores bracket three which is the fourth element i'd end up in kind of a no mans land here and worst case your program could crash or something weird will happen spinning beach balls those kinds of thing just don't make those mistakes and a makes it easy to make those mistakes so the onus is really on you pro grammatically questions on this use of arrays. Question on this use of arrays yeah in back a really good question is there any way to create an array just by using syntax alone without prompting the human for it short answer yes if you want to have an array of integers called for instance array you could actually do like 13 42 50. Something like this this would give you an array if you use this syntax this would give you an array of size 3 where the three values by default are 13 42 and 50 it's not syntax we'll use for now but there is syntax like that it's not quite as user friendly though as other languages if you've indeed programmed before other questions on this use of arrays yeah in front is there a way to copy what. What of is there a way to calculate the length of an array short answer no and i'm about to show you one demonstration of this those of you who have programmed before in java in javascript and certain other languages it's very easy to get the length of an array you essentially just ask the array what's its length a does not give you that capability the onus is entirely on you and me to remember as with another variable like a how long the array is. Let me go ahead and do this i'm going to go ahead and open up sort of a baking style a program that i wrote in advance here which kind of escalates quickly but there's not really too many new ideas here except for the array specifics so this is scores a remade this time and notice what i have one i've included cs50 hand standard i of at the top so that's the same i have declared a constant called a set it equal to 3 that is now the same. My most recent change i did introduce an average function which was one of the remaining concerns that i could compute the average with some kind of loop 2 that average function is going to return a float which is what i want i want my average to be a float with the fraction but notice this in answer to your question if i want a function called average to do something like iterate over an array step by step by step add up all of the numbers and divide by the total number of numbers i need to give it the array. Of numbers and i need to tell it how many of those numbers are so i literally have to pass in two values meanwhile this code is the same as before inside of main i'm declaring a variable called scores of size a i'm iterating from i to a and actually yep and then in this loop i'm assigning each of the scores a return value of get int the last line of main is this print out the average with percent of but don't just do it manually by adding and dividing. With parentheses call the average function pass in the length of the array and the array itself and hope that it returns a float that then gets plugged into percent of so i would claim that pretty much all of this even though it's a lot should be familiar there's no real new ideas except for this use of the global variable now and this average function so let me scroll down to the average function because this is the takeaway from this final example in this example here let me scroll down. To the average function copy pasted the prototype for the very first line and here's how i'm computing the average there's different ways of doing this but here's kind of an accumulator way on line 28 i'm declaring a variable inside of the average function called sum and i'm just initializing it to 0 why mentally i want to add up all of the persons scores and then i want to divide by the total and that's my mathematical average so here's my loop where i'm iterating from 0 up to but not through the length. So that should be three times i am adding to the sum variable whatever is at the i the location so to speak of the array so this is array bracket 0 array bracket 1 array bracket 2 on each iteration and then the last thing i'm doing is kind of a nice one liner i'm dividing the sum which is an int which is the sum of 72 73 33 divided by the length which is 3 but 3 is not a float so i cast it to a float so that the end value hopefully is going to be 59 3. 3 3 3 3 3 3 3 and so forth so the only thing that's weird syntactically is this though when you define a function in a that takes an argument that isn't just a simple char isn't just a simple integer it's actually an array you don't have to know the arrays length in advance you can just put square brackets after the name you give it and i don't have to call it array i could call it a or a or a or anything else i called it array just to make clear that it's an array but you do need to know the length somehow. Of questions on combining those ideas in that their way any questions no all right well we've only dealt with numbers thus far it would be nice to actually deal with letters and words and paragraphs and the like much like our readability example but i think first some snacks and some fruit are served in the transept so we'll see you in 10 see you in 10. So we're back and up until now we've been representing just numbers underneath the hood but we've introduced arrays which gave us this ability recall to store numbers back to back to back so it turns out you actually had this capability for the past week even though you might not have realized it and let me propose that we first consider a very simple example of three chars instead of three integers and for simplistically i'm going to call them c1 c2 and c3 just for the sake of discussion but i'm going to put our familiar characters hi exclamation point in those variables. Variables using single quotes because again that's what you do when using individual charge to make the point that i can store three chars in three separate variables so let me go ahead and go over to is code here and let me create something called high dot a and in this program i'll first include standard i of doth in main void as before and then inside of main let's just do exactly that char a one equals quote unquote capital a char a two equals quote unquote capital i char a three. Equals quote unquote exclamation point so clearly not the best approach but just for demonstration sake and here now that you understand hopefully from week one that really number and really from week zero that numbers are just letters which can be something more too we can really just use our basic understanding of a to tinker with these ideas now and see them such that there is indeed going to be no magic happening for us ultimately so let me go ahead and print out three characters percent a percent a percent a. Backslash a and then print out c1 c2 c3 so i've got three separate placeholders and we haven't really had occasion to use percent a but it means put char here unlike percent a which is put a whole string here or percent i put an integer let me go ahead and make high no syntax errors dot slash high and it should print out high in exclamation points because i'm printing out just three simple characters but per our discussion as far back as week zero letters are just numbers and numbers. Are just letters it just depends on the context in which we use them so let me change this percent a to an i and i'm going to add a space just so that you can obviously separate one number from another change this to i change this to i but still print out c1 c2 c3 so no integers per be let me just print out those chars let me do make high no errors dot slash high and now i see 72 73 33 so in the case of chars and its you can actually treat both. One as the other so long as you have enough bits to fit one in the other you don't have to cast even or do anything explicitly you do have to cast one sort of converting an integer to a float to make clear to the compiler that you really intend to do this because that could be destructive if you can't quite represent the number as you intend but in this case here i think we're of just poking around and seeing what's going on underneath the hood well what is going on underneath the hood memory wise well something very similar here's that canvas of memory and maybe we got lucky and it's in the top left hand. C1 c2 c3 but these are just three individual characters but we're getting awfully close to what we last week called a string right which are just characters a sequence of characters from left to right and in fact i think if we combine sort of this revelation that these are just numbers underneath the hood back to back to back combined with the idea of an array from earlier we can start to kind of see what's really going on because indeed underneath the hood this is just a number so we can see what's going on. 72 73 33 and really if we go lower level than that it's these three patterns of zeros and ones that's all that's going on inside of the computer but it's our use of int that shows it to us as an integer it's our use of char that makes it clear that it's a char or equivalently percent i and percent a respectively but what exactly is a string well it's really just a sequence of characters and so why don't we go there let me propose that we actually give ourselves an actual string call. So if i go back to is code here let me shorten this program and just give myself a single strings set it equal to high exclamation point in double quotes and then below that let's go ahead and print out percent a backslash a and then a itself and then turns out for reasons we'll soon see i do need to include the cs50 library so as to use the actual keyword string here even though i'm not using get string but more on that another time but if i now use the cup i can actually use the cup string. Do make high it does compile dot slash high and it still prints out the exact same thing but what's going on inside of the computers memory when i use a string called a instead of three chars well you can kind of think of the string as taking up at least three bytes a i exclamation point but it's not three separate variables it's one variable but what does this really look like now especially if i add back the yellow lines a is really just an array of characters. So we called it a string last week and i claim today that this is kind of an abstraction in the cs50 library that's giving us this phrase string but it's really just an array of size at least three here where a bracket zero presumably gives me the is bracket one is the is bracket two is the exclamation point but just by saying string all of that happens automatically i don't even need to tell the computer how many charts are going to be in the string all at once so in fact let me go over to maybe the first one. Be a variant of this program and we can see this syntactically so instead of printing out the whole string with percent a let me actually be a little curious and print out percent a percent a percent a and then changes to a bracket 0 a bracket 1 a bracket 2 which is not better in any sense this is way more tedious now but it does demonstrate that i can treats here in week 2 as though it's an array which means even in week 1 it was an array we just didn't know it we didn't have the syntax. With which to express that so if i now do make high still compiles dot slash high same exact output but i'm now just kind of manipulating the string in these different ways because i know a string is just an array of characters so i can treats with the square bracket notation but how do i know how does the computer know where high ends and this is where strings get a little dangerous like a char is one byte no matter what one char one character that's it but a string recall my question. From earlier could be no bytes if it's you would think could be zero bytes if you have nothing in it inside the quotes it could be one character to 10 100 like i claimed but how does the computer know where strings end like how does the computer not know that the string is not the whole row of memory here how does it know that it ends here well turns out all this time when we've been using quote unquote string and using get string from the cs50 library there's actually a special sent in order. Value at the end of every string in a computers memory that tells the computer string stops here and the sentinel value and by sentinel i just mean special value that the world decided on decades ago is all zero bits if you have a byte with all zero bits in it that means string ends here so the implication is that the computer now using a loop or something can print out char char char of done because it sees this special value if it didn't have that it. It might blindly go char char char char printing out values of memory that don't belong to that given string so i was correcting myself verbally a moment ago because i said that this string is of length three it's three bytes but it's not every string in the world both last week and now this is actually a plus one bytes where a is the actual human length that you care about a i exclamation point or three but it's always going to use one extra byte for this so called zero value at the end. Zero value is very tedious to write as zero as eight zero bits so we would actually typically just write it as a zero but you don't want to confuse a zero on the screen is actually being like the number zero on the keyboard and so we would actually typically write this symbol with a backslash zero so this is the char based representation of zero so it means the exact same thing this is just a notation that indicates that this is eight zero bits but the slash just makes clear that it's not literally the number zero that you want. See on the screen it's a sentinel value that is terminating this here string so now what can i do once i know this information well i can actually even see this let me go back to this code here in is code let me change these percent is to percent is just like before and now we'll see again those same numbers make high dot slash high there are the three i can technically poke around a little bit further percent i one more and let's look at a bracket three i was not. Exaggerating earlier when i said in general if you go past the end of an array bad things can happen but in this case i know that there is one more thing at the end of this array because this is how strings are built this is not a cs50 thing this is a thing in a every string in the world in double quotes ends with a backslash 0 that is 8 0 bits so if i really want i can see this by printing out a bracket 3 which is the fourth and final location if i recompile my code now make high dot slash high i should. I see 72 73 33 and 0 that's always been there so i'm always using four bytes somewhat wastefully but somewhat necessarily so that the computer actually knows where that string ends so if we go back to the memory representation of this here it's just as though you have an array of integers being stored contiguously back to back to back the last one of which means this is the end of the array of characters but because i'm using quote unquote string. Because i'm using percent a and see i'm not seeing these numbers by default i'm seeing a i exclamation point unless i explicitly tell print def no no no no show me with percent i these actual integers us this then is how you can think about the string like you don't really need to think about it as being individual characters this is just a and it has some length here but it does not necessarily in a ray that you yourself have to create you sort of get it automatically just by using a. String now there's just not to add onto the jargon this backslash zero these eight zero bits there's actually a technical term for them you can call them null it's typically written in all caps like this confusingly in a couple weeks we're going to see another word pronounced null but spelled in you all left hand wasn't talking to right hand years ago but in you a means this is the zero bite that terminates strings that indicate the end of a string and fun fact we've actually seen this before even though we glossed over it here. Here's that as ii chart from last time if i focus on the leftmost column guess what is the zero as ii character no a you never seen us on the screen it's just how you pronounce eight zero bits questions on this representation of strings yeah are strings structured differently in other languages yes they are more powerful in other languages in a you have to build them yourself in this way more on that when we get to python. Other questions yeah really good question does that mean we don't have a function to get the length of the string do we have to create it short answer there is a function but you have to someone had to write code for it you can't just ask the string itself like you can in javascript or java what is the. Can it's actually more similar to python than it is to javascript or java but we'll see that in just a few minutes in fact so let's introduce maybe a couple of strings so here's two strings in the abstract called a and to and i've initialized them arbitrarily to high and by just so we can kind of explore what's going to actually happen underneath the hood so let me go back to is code let me just completely change this program to be that instead so strings equals quote unquote high string to equals quote unquote by in all caps. And then let's print them both out very simply a backslash is print out a backslash it just so we can see what's going on if i do make high dot slash high i should of course see these two strings but what's going on inside of the computers memory well in this computers memory assuming these are the only two variables involved and assuming the computer is just doing things top to bottom high is probably going to be stored somewhere like this on my canvas of memory buy is probably going to be stored there. And it's wrapping around but that's just an artists representation but notice that it is now really important that there is this null byte at the end of each string because it's how the computer is going to know where high ends and where by begins otherwise you might see high by all on the screen at once if there weren't this sentinel value indicating to print stop at this character but that's all that's going on in your program when you have two variables in this way. Really going on and things get a little more interesting here if i were to want two of these things notice that i could refer to them to as arrays so a bracket zero one two and even three to bracket zero one two and even three and four but if i want to actually really kind of blend some ideas just kind of playing around with these basic principles now notice what i can do in this version if i know i've got two arrays in is code i don't strictly. I need to do strings it and a and a that's kind of devolving back into the scores one scores two scores three mantra where i had multiple variables almost the same name even though i'm using different letters of the alphabet what if i do this string words and if i want to store two words in the computers memory fine create an array of two strings but what is a string a string is an array of characters so it's getting a little bit grippy here. Are still going to be the same words bracket 0 could certainly equal high words bracket 1 can certainly equal by just like the scores example and then if i want to print these things with percent a i can print out words bracket 0 and then i can print out percent a backslash a words bracket 1 and the example is not going to be any different in terms of its output but i've now avoided a and to i now just have one variable called words containing both of these here. Things and if i really want to poke around here's where things get even more sort of visually overwhelming but just the logical extension of these same ideas right now is the previous version where i had two variables a and to if i now use this new version where i have one variable called words just like this here the picture should follow logically like this words bracket zero is this string words bracket one is this string but what is each string it's an array of characters. So you can also think of it like this where this his words bracket 0 bracket 0 so the 0th character of the 0th word and this is words bracket 0 1 words bracket 0 2 words bracket 0 3 and then words bracket 1 0 so it's kind of like a two dimensional array almost and you can think about it that way if helpful but for now it's just applying the same principles to the code so if i go to my code here. And i've got my high and my by this is going to look a little stupid but let me change this percent a to percent a percent a percent a and print out words bracket zero words bracket zero bracket one words bracket zero bracket two to print out that three letter word and now down here let me print out percent a percent a percent a percent a because it's four letters in by exclamation point this is words bracket one but the first character words bracket one the second character. Words bracket one the third character and words bracket one the fourth character it's hard to say when you're typing a different number but that's what we get by using zero indexing so to speak make high no mistakes high says the same thing so again there's no magic like you are fully in control over what's going on inside of the computers memory and now that we have this array syntax with square brackets you can both create these things and then manipulate them or access them however you so choose. Questions on arrays or strings in this way yeah over here good question can you have an array with multiple different data types short answer no longer answer sort of but not in nearly the same user friendly way as with languages like python or javascript or others but so assume for now arrays should be the same type in a other questions. Yeah over here of really good question so for those who couldn't hear if you were to look past the end of one array would you start to see the beginning of the second in this case maybe the word by could depend on the particulars of your code. In the computer let's try this so let's get a little greedy here and go one past a i exclamation point null character by looking at words bracket 03 which should actually be our null character so that's going to be there and actually let's see let's go ahead and do this make high dot slash high still works as expected but let me change this to integer integer so we can actually see what's going on. Make high i should see the same thing but numerically and now what i think you're proposing is let's get a little crazy and go even past that to what could be location four but we know semantically doesn't exist but maybe is bumping up against by so make high dot slash high and guess what 66 is it's well just the a but yes it's 66 recall is capital a because in week zero capital a was 65 so indeed. Now we're really poking around and you can get crazy like what's 400 characters away and see what's going on there eventually your program will probably crash and so don't poke around too much but more on that in the coming days too all right well how about some other revelations and problem solving now coming back to the question about strings length earlier and we'll see if we can then tie this all together to something like cryptography in the end and manipulating strings for the purpose of sending them securely so let me propose that we go into is code here again in a moment. And i'm going to create a program called length let's actually figure out ourselves the length of a string initially so i'm going to go ahead and code length a i'm going to go ahead and include cs50 a i'm going to include standard to hint main void and then inside of main i'm going to prompt the user for their name get string quote unquote name and then i'm going to go ahead and i want to count the length of this string but i know what a string is now it's char char char char. The null character so i can look for that and i can write this in a few different ways i know a bunch of different types of loops now but i'm going to go with a while loop by first declaring a variable a for number of characters set at equal to zero it's like starting to count with your fingers all down and i want to do the equivalent of this counting each of the letters that i type in so i can do that as follows while the name variable at location a does not equal quote unquote. Quote backslash 0 which looks weird but it's just asking the question is the character at that location equal to the so called null character which is written with single quotes and backslash 0 by convention and what i want to do while that is true is just add 1 to a and then at the very bottom here let's just go ahead and print out with percent i the value of a because presumably if i type in high exclamation point i'm starting at 0 and i'm going to have a i. Exclamation point null character so i don't increment a a fourth time so let's go ahead and run down here make length dot slash length enter i guess i'm asking for names so i'll do my name for real david five characters and i indeed get five if i used a for loop i could do something similar but i think this while loop approach much like our counter from the past is fairly straightforward but what if i want to do this what if i want to make another function. Well i could do that let me us all right let's do this let's write a quick function called string length it's going to take a string called a or whatever is input and then you know what let's just do this in that function i'm going to borrow my code for a moment ago i'm going to paste it into this function but i'm not going to print out the length i'm going to return the length end so i have a helper function of sorts that's going to hand me back the length of the string and that's why this returns an int but takes a string as its a. Argument how do i use this well first i do need to copy the prototype so i don't get into trouble as before semicolon and then in my main function what i think i can do now is something like this i can do int length equals get the string length of the name variable that was just typed in and now using print percent i print out length semicolon so exact same logic the only thing i've done that's different this time is i've added a helper function just to demonstrate. How i can take some pretty basic functionality find the length of a string and modularize it into a function abstracted away so i never again have to copy paste that for loop i now have a function called string length that will solve this problem for me dot slash whoops wrong program make length huh use of undeclared identifier name what did i do wrong apparently on line 16 of length a what did i do wrong here yeah in front. Good good perfect terminology so name is local to main the scope of name is main those sound similar but different words and so i actually should be calling this a because a is the name of the local variable being passed in even though it happens to be one and the same as name because on line 9 i'm indeed passed in. Passing in name as the argument all right so this is where again copy paste can sometimes get you into trouble let's try to make length again now it works dot slash length a a a id and now we have a function that seems to be working but this is such commodity functionality like my god like surely someone before us has written a function to get the length of a string before and indeed other people have so it turns out that in a just as you have the standard to library you also have a string library whose header file is called. Appropriately string doth in fact cs50 has documentation therefore in its own manual pages so to speak along with some sample usage thereof but it turns out in the string library there is a very popular function analogous to the python one that you asked about earlier called st lang where st lang one word no underscores just figures out the length of a string and honestly i've never looked at its source code but it probably uses a while loop maybe it uses a for loop but it certainly uses the same idea of just iterating. Is walking from left to right over a variable in order to figure out what the length of a given string is so how do we use this well if i go back to is code here i can throw away the entirety of my string length function i can throw away the prototype therefore and i can include a third header file string a inside of which i claim now is this function called st lang that i can just now use out of the box for free because someone else wrote this function for free. And string a will teach the compiler that it exists so if i now do make length and dot slash length now i have a similarly working program that doesn't bother having me write unnecessary code so this is another example of a library the string library is just going to make our lives easier but not having to for us not having to reinvent some wheel all right well where else does this get interesting how about something like this. Let's go back into is code here let's create a program called string a we'll play around with our own strings that's going to start similarly so let's include cs50 a let's include standard i of let's include string a so we can use that same st lang function int main void and inside of this let's do this let's get a strings and prompt the user for any old string as input all right and then let's go ahead and maybe. Print out quote unquote output and i'm just going to line up my spaces just right because these words are slightly different lengths but we'll see why i'm doing this it's just for aesthetic sake in a moment and let's go ahead now and do this if i want to print out every character in a string how can i now do this well this is actually a pretty common task even though this version thereof will seem pointless for int i gets 0 i is less than the length of a i plus plus is just the conventional way to start. A loop that iterates from left to right over a string of that length and then let's go ahead and print out each character percent a printing out the string at location i using our fancy new array syntax and at the very end of this program let's just print out a new line character just to move the cursor to the bottom like we've done in the past so this is kind of a stupid program like i am reinventing the wheel that is the percent a format code i already know that print can print out a whole string suppose it didn't. I forgot about percent a and i only knew about percent a these lines of code here collectively will print out the entirety of a string character by character based on its length so if i compile this program make string dot slash string and type in my name for instance david the output is a a a id and here's why i hit the space bar an extra time because i wanted input and output to line up nicely so we could see that they're in fact the same length so let me just stipulate. But there is an inefficiency with this line of code let's talk about design instinctively what is maybe bad about this line of code 9 line 9 that i've highlighted this one is subtle let's go over here yeah i'm calling st lang inside of the loop again and again and again why well recall how we were talking about the line of code. How for loops work when we walk through it last week that middle part of the for loop in between the semicolons keeps getting checked keeps getting checked keeps getting checked and so if you put a function call there which is totally fine syntactically you're asking the same damn question again and again and again and the length of david a a a id is never changing so it's sterling implemented decades ago by some other human has some kind of loop in it and you're literally making that code run again and again and again just to get the same answer five again and again so i think your instinct. Is right i could come up with another variable outside of the loop i could do something like this int length equals sterling of a and then i could just plug that in but there's a slightly more elegant way if you like doing things with slightly less code this is correct as i've now written it's less efficient it's more efficient because i'm only calling sterling once now on this new line nine but a more common way to write this would typically be to do something like this after initializing i. You can also initialize something else like length and you can set length equal to st lang of a then your semicolon and now you can say while i is less than that length or i can tighten this up further if it's just a number and it's a super short loop might as well just call it a so this now would be sort of a canonical way of implementing the exact same idea but without the inefficiency because now you're calling st lang in the initialization part of your for loop not inside of the boolean expression. That gets checked and executed again and again yeah correct well i'm declaring i as an int but by way of the comma i am also declaring a as an int so they've got to be the same type for this trick to work good observation other questions on this one here all right well let's kind of play around further here let me propose that this is. There's other libraries and header files as well that you might find useful there's also something called a type which relates to types and is that's got a bunch of useful functions that we can actually see if we visit the documentation here but before we get there let me actually whip up a program that maybe does something a little bit fun albeit low level like forcing some string to uppercase if the human types it in in lowercase so let me go ahead and write a program called uppercase a let me go ahead and give myself the same header files include cs50 a. Include standard i of doth and for now let's include string doth for the length and let's go ahead and have in main void as before and inside of main let's give myself a strings equating get string before just so i know what the string is initially now i'm going to print out proactively after with two spaces just so that things line up aesthetically on the screen because after is one character shorter and now i'm going to do the same technique as before for int i equals. A equals the string length of a i is less than a i plus plus and then inside of this loop what do i want to do logically i want to force these characters to uppercase if they are in fact lowercase and so how might i do this well there's a bunch of ways to express this but i'm going to kind of do it maybe the most straightforward way even if you've not seen this before if the current letter in the string at location i because i'm in a loop starting from 0. All the way up to but not through the string length is greater than equal to a lowercase a in single quotes and that letter is less than or equal to a lowercase a what does this mean in english well this essentially means if lowercase logically if it's greater than or equal to little a and less than or equal to little a it's somewhere between a and a in lowercase what do i want to do well i want to force it to uppercase so i want to print out. A character without a new line yet that prints out the current character but force it to uppercase well how can i do this well this is where this sort of gets into some low level hacking but notice the same as ii chart here's our uppercase letters from last time here's our lowercase characters and let me highlight those does anyone notice a relationship between capital a and lowercase a that happens to be the same for capital a and lowercase a. Yeah like this pattern is true so 97 minus 65 is 32 and that's true for every lowercase and uppercase letter respectively so i can kind of leverage that and this is not a cs50 thing this is as ii this is in turn unicode this is how modern computers work so if i go back to is code here you know what i could do let's just literally subtract 32 but because i'm displaying this as a char not as an int i'm going to see the lowercase letter seemingly become uppercase. Instead else if it's not lowercase maybe it's punk maybe it's already uppercase maybe it is punctuation let's just go ahead and print out with percent a the original character unaltered and then at the very end of this program let's print a new line just to move the cursor to the next line all right so let's do make uppercase and let me type dot slash uppercase and i'll type in a a a id all lowercase and now you'll see it's in all caps if though i type in maybe my last name but can't. Capitalized a that's of the rest of it will still be capitalized for me now i don't love this technique it's a little bit fragile because i kind of had to do some match i had to check my reference sheet and then incorporate it into my program even though it will be correct i could be a little more clever i could actually do something like this well whatever the value of lowercase is lowercase a is minus whatever the value of capital a is and i could actually do it arithmetically even though that too is somewhat inefficient in that it's asking the same question again and again. The compiler is probably smart enough to optimize that and frankly for those more comfortable a good compiler will also notice no no no no you don't want to call sterling again and again the compiler can do some of these optimizations for you but it's still good practice to get into yourself but there's probably a better way instead of kind of rolling this solution ourselves and subtracting 32 or doing any arithmetic let's use that a type library let me go back up to my header files let's additionally include type a. To pretend like i read the documentation in advance which i did in fact and let's instead of doing any match here let's use a function that exists in that library called to upper and pass to it whatever the current character is in sat location i otherwise i still print out the unchanged character and let me go ahead and do make uppercase dot slash uppercase and now without any match no subtracting 32 that too also works. But it gets better if you read the documentation for 2upper it turns out its documentation tells you if a is already uppercase it just passes it through for you so you don't even need to ask this conditional question i can actually cut this to my clipboard get rid of all of this and just replace that one line only and just let 2upper handle the situation for me because again its documentation has assured me that if it's already uppercase it's just going to return the original. So if i make uppercase this time dot slash uppercase now it works and now things are getting kind of fun i mean these are mundane tasks admittedly but at least i'm standing on the shoulders of smart people who came before me who implemented the string library the a type library heck even the cs50 library so i don't need to reinvent any of those wheels questions on any of these library techniques it's all still arrays it's all still strings and charters. But now we're leveraging libraries to solve some of our problems for us all right so let's come full circle to where we began wherein i mentioned that some programs include support for command line arguments like clang takes command line arguments words after the word clang cd which you've used in linux takes command line arguments if you type cd space pset1 or cd space mario in order to change directories into another folder if you dorm like i did earlier. You can remove a file by using a command line argument a second word that tells the computer what to remove well it turns out that you too can write code that takes words at the command prompt and uses them as input up until now you and i have only gotten user input via get string get int get flow and functions like that you too can write code that take command line arguments which frankly just saved the human time they can type their entire thought at the command line hit enter and boom the program can complete without prompting them. And re prompting them again so here's where we can now start to take off some more training wheels up until now we've just put void inside of the parentheses here any time we implement main it turns out that you can put something else in parentheses when using a it's a helpful but you can replace void with this bigger expression but it's two things int called arc by convention and a string but not a string actually. An array of strings called arg and these terms are a little arcane but arc means argument count how many words did the human type at the prompt arg stands for argument vector which is generally another term for an array you've heard it perhaps from mathematics it's like a list of values or in this case a list of command line arguments soc is special if you declare main as not taking void inside of parentheses but rather an int and an array of strings a will figure out whatever the human typed at the prompt. Hand it to you as an array and the length thereof so if i want to leverage this i can start to implement some programs of my own that actually incorporate command line arguments for instance let me go back in a moment here to is code let me create a program for instance called greet a that's just going to greet the user in a few different ways so let me first do it the old way cs50 a let me include standard to a let me do int main void still. Old way and if i want to greet myself or carter or julia or anyone else i could do old fashioned now get the answer from the user get string let's prompt for what's your name question mark just like we did in scratch and then do print of hello comma percent a backslash a answer so we've done this many times now this week and last this is the old school way now of getting command line of getting user input by prompting them for it so if i do make. Greet dot slash greet there's no command line arguments at the prompt i'm literally just running the programs name if i had entered though now get string kicks in asks me for my name and the program then greets me but i can do otherwise i could do something like this instead first answers a little generic so let's first change this back to name and back to name but that's a minor improvement there just stylistically let's though introduce now a command line argument so that i can just greet myself. By running the program hitting enter and being done no more get string so i'm going to go ahead and change void to int arc string arg with square brackets the square brackets means it's an array string means it's an array of strings and arc again is just an integer of the number of words typed now i'm going to somewhat dangerously going to do this i'm going to get rid of my use of get string altogether and i'm going to change this line to be not name which no one. No longer exists but i'm going to go into this array called arg and i'm going to go into location one so i'm doing this kind of on faith i haven't explained what i'm doing yet but i'm going to do make greet now dot slash greet and now i'm going to type my name at the command line just like with pm with clang with cd with any of the commands you've written with multiple words i'm going to greet literally david so i hit enter and voila i've somehow gotten access to what i. Typed at the prompt by accessing this special parameter called arg technically you could call it anything you want but the convention is arg and arc from right to left here just a guess then what if i change this to print out bracket zero and recompile the code and i run greet david what might it say instinctively any hunches yeah so it's going to say hello greet. So it turns out you get one for free whatever the name of your program is is always accessible in arg at location 0 that's just because it's a handy feature in case there's an error or you need to tell the user how to use the program you know what the command is that they ran but at location 1 maybe 2 maybe 3 are the additional words that the human might have typed in well let's do something a little smarter than this let me go back to version 1 let me recompile it make greet let me rerun greet david. And this seems to work fine what if i get a little curious and print out location two let me recompile the code make greet dot slash greet david enter of there's null and i mentioned we'd see null and here's one incarnation thereof but this is clearly wrong so i probably don't want to even let the user do this because i don't want them to see bogus output like this is arguably a bug in the code that it even bothered to show this by default so what could i do instead well what if i do this. Arc equals equals 2 then go ahead and comfortably say print hello arg bracket 1 else if the human did not give exactly two arguments at the prompt let's just print out some default value like hello world like from last week in other words now i'm doing this error checking with a conditional making sure with this boolean expression only if arc equals equals 2 and therefore has two words in arg. Do you want to proceed and so now if i do make greet again greet david this now works but if i don't cooperate and i just run greet what should it say just hello world if i run david alan as two words what should it say hello world because that's not exactly equal to two again the first word in arg is always the programs name the second word is whatever the human then has typed now if we don't even know in advance how many words they're going to be. Combined today is ideas this is going to look a little weird but it's the same thing as before for int i gets 0 i is less than how about arc i and then inside of this loop i can print out percent a maybe backslash a comma and then print out arg bracket i so i can have a loop that iterates arc number of times once for every word at the prompt i. And print out re bracket i which is the with word in that array from left to right and so if i now make greet and i do greet alone i just see the programs name if i do greet david i see those two one after the other if i do david alan i get those three words if i keep going i'll get more and more words so using just the length of the array and the name of the array i can actually do quite a bit there now there's actually some fun things. You can do with this and this is sort of beside the point but there's this thing in the world called as ii art which is making pictures and beautiful things just using as ii or maybe nowadays unicode characters but without using emo i like emo i kind of make this a little too easy but if all you have are traditional largely english letters and punctuation you can actually do some interesting things on linux systems for instance if i go back to is code here let me increase the size of my terminal window here and it turns out that we've are installed really for no compelling reason but just for fun. A program called cow say which has a cow say something so if i want to have a cow say moo in as ii art i can do this and you get an adorable cow saying something like moo on the screen but moo is a command line argument that is clearly modifying the output of this program because i could also change it to say hello world and now the cow is going to say that instead so it takes multiple command line arguments if you will but it also takes what are called flags or switches whereby any command line argument that starts with a dash is used. Like a special configuration option that you would only know exists by reading the documentation or seeing a demonstration and if i have my syntax right if i do cow say dash of and maybe i'll do let's see instead of this cow say how about i'll do dash of for file and i'm going to change it into duck mode i'm going to have this version of the as ii art say quack so it's a tiny little duck there but it's saying quack and you can kind of waste a lot of time doing this i can do cow say dash of. Dragon and say something like car and this is just amazing again not really academically compelling but it does demonstrate again command line arguments which are everywhere and you've indeed been using them already but there's one other feature we wanted to introduce you to today which will be a useful building block which will also reveal one other thing about the code that we've been writing it turns out that all of the programs we've been writing thus far eventually obviously exit because you see your prompt again. Unless you have an infinite loop such that it never ends but eventually they exit and secretly every program we've written thus far actually has what's called an exit status it's like a special return value from the program itself that by default is always 0 0 as a number in the world generally means everything is of the flip side of that is because the world tends to use integers and you've got like 4 billion possibilities like every other number in the world when it comes to a programs exit status is bad if it's 1 it's 0. It's probably bad if it's negative one it's bad and in fact you've probably seen this in the real world if you've ever had a random error message on the screen here's a screenshot of zoom for instance and that screenshot somewhat confusingly or sort of unknowingly has an error code like 1132 that probably means that the zoom software that some other humans wrote incorrectly somehow had an error and it did not exit with status 0 it exited with status 1132 and somewhere at zoom there's probably. File or book that tells the programmers what this error code actually means this is not useful for you and me there's some programmer at zoom who would probably like of i know what i did or my colleague did wrong in this case you've seen this elsewhere even though this is not quite the same thing but we'll talk about this in a few weeks if you've ever seen 404 like numbers are everywhere and on the web 404 means like file not found it means you made a typo the web server deleted a file or something like that but this is just to say numbers are so often used to signify. Or represent errors even though that's not an exit status per be that's an help status code which will soon see but you have access to exit status is as it relates to command line software already up until now this is how we've been writing main now with command line arguments but we've also been writing main within int return value and you've never used this we didn't talk about this last week i just asked that you trust me and just keep copying and pasting this but that ends means that even your. Can return values which can be useful even if you don't use command line arguments and we just go back to the original version like void so for instance if i go ahead and open up for instance is code again i'll get rid of the dragon and let's do one other program here called status just to kind of play around with the idea of these so called exit statuses let me just demonstrate the idea with an include cs50 a include standard i of and then. Int main and here i'll do int arc string arg and then inside of main let's do a similar program to before like the hello world so print hello percent a backslash a then let's print out arg 1 but i only want to execute that line if the human gave me a command line argument otherwise i don't want to even say some default like hello world i just want to abort early and just exit the program no output whatsoever. So i could do this if arc does not equal 2 and it's a single equals but it's a bang an exclamation point means not equals so this is the opposite of equals equals then previously i would have just printed hello world but now i want to print out an error message like missing command line argument just to explain to the user why the program is about to terminate and then i can return 1 it's kind of arbitrary i could also return 1 1 3 2. Start there this is the only possible error that could go wrong in my program so i'm going to start at 1 zoom clearly has 1 000 plus possible things that can go wrong in their source code which is why the number got as big as 1132 but i'm just going to arbitrarily but conventionally return 1 but if everything is of and it is not the case that arc does not equal 2 and i actually get to line 11 i'm going to return 0 because 0 again i claim signifies success. This time every program we've written you've written has secretly exited with zero by default but now that our programs are getting more sophisticated when something goes wrong it turns out it's useful to have the power to just return some other value even though the user is not going to see it even though the zoom user shouldn't see it it's still there it's diagnostically useful to you or in the case of a class to your of or to or a so if i do make status now to compile this program and run status. And type my first name i think this is a success it should say hello david and secretly exit with zero if you really want to see the zero there's this arcane command you can type you can literally type at your prompt echo it's weird symbology but it's what the humans chose decades ago this will just show you what did the most recently run program secretly exit with so if i do this in is code i can do exit enter and there's that secret zero. I could have been doing this this week and last week it's just not that interesting but it is interesting or at least marginally so if i rerun status and maybe i don't provide a command line argument or i provide too many so arc does not equal 2 and i hit enter i get yelled at with the error message but i can see the secret status code which is indeed 1 and so now if you're ever in the habit in either a class like this or in the real world where you're automatically testing your code be it with check 50 or in the real world things called unit tests. And other third party software those tests can actually detect these exit statuses and know did your code succeed or fail 0 or 1 and if there's different types of failures it can detect status 2 status 3 status 1 132 which is just one other tool in your toolkit but all of that is terribly low level and really the goal of this week and really today and really code more generally is to solve problems so let's consider an increasingly important one which is the ability to send. Information securely whether it is in file format tirelessly or any other cryptography is the art and the science of encrypting scrambling information so that even if i write a secret message to you and i send it through this open audience with so many nosy eyes who could look at the message if i've encrypted this message none of them should be able to read it only you whoever you are to whom i intended that message in the world of cryptography then encryption means scrambling the information so that only you and the recipient. And let me propose a couple of pieces of vocabulary plain text is any message written in english or any human language that you want to send and write yourself cypher text is what you want to convert it to before you just hand it off to a bunch of random strangers in the audience or a bunch of servers on the internet any one of whom could look at your message so in the black box is what we're going to call a cipher an algorithm for encrypting or sending so we're going to call it a cipher. Scrambling information in a reversible way it doesn't suffice to just scramble the information randomly otherwise the recipient can't do anything with it it's an algorithm a cipher that encrypts it in such a way that someone else can decrypt it and here's a common way most ciphers take as input not only the plain text message in english or whatever else but also a key and it's metaphorically like a key to open a lock but it's technically generally a number like a really big number made up of lots of big numbers. And not even 32 not even 64 sometimes 1 024 bits which is crazy unpronounceable large but the probability that someone is going to guess your key is just so so small that for all intents and purposes you are in fact secure so what's an example of this for instance suppose the secret message i want to send is innocuously just high exclamation point well it'd be pretty stupid to write high on a piece of paper hand it to someone in the audience and expect it to get all the way to the back without someone kind of glancing at it and obviously seeing and reading the plain text. So what if i though agree with someone in back for instance that our secret is going to be 1 and we have to agree upon that secret in advance but 1 just means that that is my key and let me propose that according to one popular cipher if i want to send high exclamation point change the a to an i and the i to a a that is increment effectively every letter of the alphabet by 1 and if you get to a a wrap back around to a for instance so shift the alphabet by one place in this case and send this message now. Instead so is that secure well if one of you kind of nosey lee looks at this sheet of paper you won't see high you will see some information leak in this algorithm you'll see an exclamation point so i'm enthusiastically saying something but you won't know what the message is unless you decrypt it now that said is this very secure really in practice i mean not really like if you know i'm just using a key and i'm using the english alphabet you could probably brute force your way to a solution by just trying one trying to try. Trying 25 go through all the possibilities tediously but eventually it's probably going to pop out this is actually known though as the caesar cipher and back in the day before anyone else knew about or invented encryption caesar julius caesar was known to use a cipher like this using a key of three literally and i guess it works of if you're literally the first human in the world by lore to have thought of this idea but of course anyone who intercepts it could attack it nonetheless and figure things out a bit mathematically. This is kind of more common this is called rot13 on the internet for rotate the letters of the alphabet 13 that changes high to us exclamation point you might think what's better than 13 well let's double the security rot26 why is this stupid i mean there's like 26 letters in the alphabet so like a becomes a so that doesn't really help of wait i'm pointing at something that's not on the screen damn it suppose the message is more lovingly i love you instead of just high same exact approach whether or not. Punctuation i love you with an input of 13 might now become this and now it's getting a little less obvious what the cipher text actually represents and now what's twice as secure as 13 well 26 is surely better but of course if you rotate 26 places that of course just gives you the same thing so there's a limit to this but again that just speaks to the cipher being used which is very simple there's much much better more sophisticated mathematical ciphers that are used we're just starting with something simple here. For decryption if i'm using a key of 1 how do i reverse the process yeah so i just minus 1 so a becomes a a becomes a a becomes a and if it's 13 i subtract 13 instead or whatever the key is so long as sender and receiver actually know it so in this case here this is actually the message with which we began class if we have this message here and i used a key of 1 to encrypt it well decrypting it might involve doing something like this here's those same letters on the screen. Before we adjourn i'll mention too that we might have encrypted a message in eight characters this whole day so if any of you took the time and procrastinated and figured out what the light bulb spelled and they didn't seem to spell anything in english well here now is the solution for cracking it this if i subtract 1 becomes what a becomes to and this is obviously see where we're going with this and if we keep going subtracting 1 so indeed we're at the end of class now because this was cs50 and the last thing we have to say is we have hundreds of ducks waiting for you. Outside so on the way out grab your own rubber duck. You