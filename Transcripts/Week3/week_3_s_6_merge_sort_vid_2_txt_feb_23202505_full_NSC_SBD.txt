All right so by now we've talked about a couple of different sorting algorithms that are pretty straightforward to work with hopefully we've got bubble sort insertion sort and selection sort and what we do know is that all of them have in common is that they have a sort of worst case scenario run time of a squared can we do any better than that well the answer happens to be yes we can using an algorithm called merge sort now in merge sort the idea. Is to sort smaller arrays and then combine those arrays together or merge them as in the name of the algorithm itself in sorted order so instead of having to think about we have one six element array let's think instead that we have six one element arrays and then let's just recombine them in the correct order and merge them together that would be one way to sort it and that's what merge sort does and it leverages something called recursion which we'll talk about soon in another video. Want to get a better understanding of how recursion works you might want to take a look at that video before coming and watching this one because this is going to talk about recursion quite a bit merge sort is definitely the most complicated of the four different types of sorts that we cover in the class and so i'm going to go through this one a little more slowly than the other ones but the algorithm for merge sort itself is actually pretty few steps we're basically going to say we're going to sort the left half of the array sort the right half of the array and then merge the two halves together. That is fundamentally what merge sort is all about of course in practice it's a little more detailed than that but let's go through it now so here's the same six element array we've been sorting all the time and we're going to start to follow our steps of pseudo code which is we want to sort the left half of this brick red array so we're just going to focus on this part for now and actually just to make things a little bit easier because i've coloured different things in different ways throughout this video we're going to refer to this point this half of the array this left half. Of the overall red array from this point forward this is the purple half of the array so we are now in the middle of sorting the left half of the array but we don't know how to do that we don't know how to sort the left half of the array so why don't we just go back to our merge sort steps again well if i don't know how to sort the left half of the array i'm just going to start again sort the left half of this array so now i just want to focus on this part of the array the left half and i'm sort of arbitrarily deciding that my left half is going to be smaller than my right half i have three elements. I can't divide it evenly i can't have one and a half elements on each side so the only time i'm consistent as long as i always choose for example in this case the left side is smaller that all be fine for merge sorts purposes so now i'm left with this single element this 5 how do i sort a one element array well the good news here is i actually don't have to sort it at all a single element array must necessarily be sorted so i can say that if i'm sorting the left half of the purple part that is sorted so we're just going to call that sorted and set it aside for now. So now i want to go back to the right half of the purple part that's this how do i sort this array this sub array let's just go back to our steps again i want to sort the left half only the left half is now 2 it's a single element i know how to sort a single element so i've sorted the left half of the right half of the purple that's where we are that's sorted now i go back and i sort the right half. Of the left half of the purple which is the 1 1 is a single element it's really easy to sort it's in sorted position now is the first time i finally get to this third step of merge sort where i merge the two halves together so here what i have to do is consider these two light green halves and i have to decide which one has the lower element in this case it's 1 so what i do is i take the 1 and i put it in the first position of some new hypothetical array. I compare the 2 against nothing and i ask which one is lower well 2 or nothing what's lower is 2 so now let's re frame the picture because remember talking about recursion we're only focusing on the left half of the overall brick red array which we then called the purple array by this point in our steps with respect to the purple array we have sorted the left half which is 5 and the right half which is originally 2 and 1 but now we have done these merging steps and we've got that in the correct order. So now we are on step three for the entire purple array because we've already sorted the purple arrays left half and the purple arrays right half so now we need to merge these two halves together and just like we did a second ago with the two and the one we're going to compare the first element of the left part and the first element of the right part and figure out which one is smaller and make that the first element of our new array so i compare five and one and i say which one is smaller well it's one. So 1 becomes the first element of this new three element array now i have to make another decision is 5 lower or is 2 lower well 2 is lower so 2 becomes the next element of our merging step then i say is 5 lower or is nothing lower well clearly in this case the only option i have left is 5 and so now at this point in the process let's again think recursively about where we are we have sorted for the entire red array. We have just done step one we have sorted the left portion we've done so recursively but we have sorted the left portion of the overall red array so we can kind of put this aside for now because now we have to go to the next step of the merge sort process which is to sort the right half of that red array so let's go over and focus on the right half we're going to go through exactly the same steps that we just went through with the left part but now we're going to do it with this red part on the right. Left half of this array well that's pretty easy i just arbitrarily again divide it i look at it i say of well 3 is a single element single element is already sorted so i don't have to do anything which is great i can just set that one aside and say 3 is already sorted now i want to sort the right half of the not so brick red but it's still red half of the array which is this section how do i do this well it's more than one element so i'm going to go back to the beginning of my process again i'm going to sort the left half of that array so i look and i say here's the left half it's 6 it's already sorted. Now i'm going to sort the right half of the array it's 4 it's already sorted now we get to that merge step again where i have to again do these sort of side by side comparisons which one is lower is 6 lower or is 4 lower well 4 is lower so that becomes the first element of our new merged little sub array here and then i have to choose between 6 and nothing and i say 6 is the lowest remaining so now i've sorted the left half of the right half and i've sorted the right half of the right half. To merge those two portions together and again we're going to do exactly the same process that we did for the left portion i'm going to say is 3 lower or is 4 well it's 3 and then i'm going to say is 4 lower or is nothing there's nothing left on the left side then i must know that everything on the right has to be bigger than everything that's in the merged array right now so instead of saying of i'll put 4 in and then i'll put 6 in because the only thing left is on one side everything must go so that all comes down. Take a second and think about where we are at this point for the original brick red array that we started with we have gone through two of our pseudo code steps we've sorted the left half of that overall brick red array and we sorted the right half of that overall brick red array and so now the final thing we have to do is merge those two halves together and just like before we continue to ask ourselves the same question again which is lower one or three notice the little black line there. Dividing the two halves to make it more visually clear which is lower 1 or 3 well 1 is now i'm going to ask myself the question which is lower 2 or 3 that would be 2 which is lower 5 or 3 that's 3 5 or 4 it's 4 5 or 6 it's 5 6 or nothing it's 6 and so by going through this process recursively and breaking my problem down into smaller and smaller sub arrays sorting. Those merging together after a number of steps i have now completed my sort and i have everything in order here in dark blue 1 2 3 4 5 6 it's not necessarily as straightforward as something like bubble sort insertion sort or selection sort but are there some advantages here well the answer is yes there are in the worst case scenario we have to split up a elements and then we have to recombine them effectively doubling the sorted arrays as we build them up. We take two one element arrays and we turn it into a two element array we take two two element arrays we make it into a four element array and so on and so on and so on as we go in the best case scenario sort of like selection sort the array is already sorted but we don't know this we don't know this until we split it and recombine it back with this algorithm there's no shortcut here other than doing a search beforehand but that's going to add extra time as well so the result here is that we have a elements and we might have to combine them if we're doubling log a. Times mathematically that's how it works and so actually unlike the other algorithms we covered in the worst case scenario the run time of merge sort is of of a log a which in general is going to be less than or faster than a squared in the best case scenario because we still have to go through this process again it is still a log a so in the best case scenario it can be slower than say bubble sort where the array happens to be perfectly sorted as you may recall the omega there is a and not a log a. But in the worst case or maybe even an average case merge sort is actually going to be faster at the expense of maybe taking up more memory because we have to recombine and create new segments of memory for our sub arrays so merge sort is a really powerful tool to have in your toolbox once you understand recursion because it can make the speed of sorting an array that much faster my name is doug lloyd this is cs50