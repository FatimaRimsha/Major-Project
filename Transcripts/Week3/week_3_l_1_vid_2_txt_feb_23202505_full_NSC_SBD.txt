Music. You. All right this is cs50 and this is week three and as promised we thought we'd take a bit of a break on new syntax this week and focus a lot more on algorithms and implementation thereof because over the past few weeks besides scratch we've now had a and you have a lot of vocabulary now even if it might not seem yet that you fully grasp all of the functionality of this particular language with practice it'll get easier and easier but today we'd focus instead on ideas and ultimately on this how to think algorithmic. And so to take problems in the real world and try to quantize them in a way that you can map those puzzle pieces from week zero or all of this new syntax from weeks one and two on to actually writing code to solve those problems to contextualize this though we thought we'd remind you of this here chart from week zero and recall that in week zero we painted this picture where on the a axis on the horizontal was the size of the problem and the number of phone book pages increased as you went from left to right and then on the vertical axis or a axis we had time to solve so this was like how many times. How many seconds how many page turns how many units of measure whatever you're using we might actually describe the solution there too and the first algorithm we had in week zero for the phone book was like one page at a time so we plotted it with this one to one slope the second algorithm we started doing two pages at a time which did risk a bug i might have to double back one page but it was still going for the most part twice as fast so it was still a slope but sort of a two to one slope instead of one to one but the third and final algorithm recall was sort of. Fundamentally different than it was this logarithmic curve so to speak whereby it kept increasing increasing increasing but very very slowly so even if you doubled the size of the phone book as by having cambridge and austin here in massachusetts merge no big deal it was just one more page turn not another 500 or another 1 000 so think back today on that particular idea of how we began to divide and conquer the problem and that sort of gave us a fundamentally better advantage. See if we can apply this lesson learned as follows if i were to take attendance today sort of here on stage i could do it old school like 1 2 3 4 5 6 7 8 and so forth so one step at a time i could also double the speed 2 4 6 8 10 12 14 16 and so forth but i dare say we can learn a bit from week 0 and if you'll indulge me right in place could everyone stand up and think of the number 1 so right where you are just stand up if you could. Stand up and think of the number one so at this point hopefully everyone is literally thinking of the number one and the second step of this algorithm which i claim ultimately theoretically should be much faster than either my one person at a time or two people at a time step two is this pair off with someone standing and add their number to yours and remember the sum. Can be in front of behind left or right of you all right most likely most everyone in the room assuming you found someone is thinking of the number 2 now unless you're like sort of an odd person out in the row and that's fine if you're still one that's fine but most of you are probably two next step is that one of you in those pairs should sit down of. So many of you tried to sit down as quickly as possible we noticed but so next step now at this point rather most of you were thinking of the number two a few of you were thinking of the number one and that's of the next step and notice we're about to induce a loop so the rest of this is on you if still standing go back to step two. If still standing notice that this is a loop so keep going keep going if still standing. That's of but now keep going keep going keep pairing off so maybe you two all right few more seconds so step two still all right keep pairing if you're standing. All right so theoretically there's only one person standing left but clearly that's not the case that's fine i will help with the pairing because some of you are far away so let's see what's your number here sorry what's your number eight of go ahead and sit down. What's your number 46 nice of go ahead and sit down who else is standing over here what's your number you're 16 of so go ahead and sit down and behind you 48 of go ahead and sit down is anyone still standing yeah 32 nice still stand of over here 43 of nice sit down sit down and anyone else still standing here 22. Sit down anyone still standing and participating yeah where of yeah 16 of go ahead and sit down anyone else still standing of so theoretically everyone is paired off you were the last person standing so when i hit enter here having just greased the wheels to do all of the remaining edition myself we should have the total count of people in the room and recognize that unlike my algorithm which would have required pointing at each and every person. Or my second algorithm which would mean pointing at every two people twice as fast theoretically the algorithm you all just executed i dare say should have been fundamentally faster why because no matter how many people in the room maybe like if there are 1 000 people in the room there would then have been 500 just as there would be 500 pages in week zero then from 500 there's be 250 125 why because on each step of the algorithm half of you theoretically were sitting down sitting down sitting down dividing and conquering. So the total number of people in the room as of now according to your count is 231 as a backup though carter kindly did it the old fashioned way one person at a time and carter the actual number of people in the room is of so our first real world bug to be fair so theoretically that should have worked but clearly we lost some numbers along the way so a bug that we can fix today but remember that really this is just the first time. Similar in spirit to that algorithm we indeed did in week zero it's the same as the phone book example it went off the rails in this case but it's the same idea ultimately dividing and conquering and any time you have this having having having there's going to be a logger them involved there even if you're a little rusty on your match and that's fundamentally faster than just doing something end times or even end divided by two times where a is the number of people in the room or in week zero the number of pages in the phone book so even when you're using your iphone or android. Advice later today like if you search for a contact contact using auto complete it is that so called divide and conquer algorithm that's finding people in your address book it's not starting top to bottom or bottom up it's probably going roughly to the middle and then doing the top half or the bottom half repeating again and again so these ideas are everywhere and hopefully you end up finding just the one person you're looking for or in your case the one person last standing who should have theoretically had the count of everyone. Is if each of you started by representing one effectively handed off your number handed off your number handed off your number it theoretically should have coalesced in that final person standing so let's consider the connection now between this idea and what we introduced last week which was this idea of very simple data structures in your computers memory like actually using this memory as though it's kind of a grid of bytes each one of these squares recall represents one byte or eight bits and we can get a ray get rid of the hardware. Sort of abstracted away as just this grid of memory or this canvas and then we introduced a raise last week and what was the key definition of an array how would you describe an array what is it anyone what's an array yeah in the middle a collection a collection and i don't love data types only because in a it tends to be the same type so a collection of data i do like that but there's one other key characteristic do you want to be more precise. Just a collection something about where it is potentially strings but strings are just an example of putting char char char char it could certainly be integers or floating point values another characteristic it's what sorry it's not necessarily ordered actually we'll come back to that today it could be in any order and certainly a string isn't necessarily in sorted order it's in whatever the word is it's a list in concept but there was something key about where we put things in memory. Consecutive memory is consecutive aka contiguous an array is an important and see because yes it's a list of values yes it's a collection of values but the real key distinction in an array in a is that it's contiguous the bytes are back to back to back somewhere in the computers memory at least for any given data type be it an int a float a bigger string all of the characters are back to back to back in the computers memory not spread all out even if you have space elsewhere. So with that said we can actually start to solve problems with that mindset and for instance if i kind of pair this down to just an abstract array of size 1234567 for instance suppose that there are these numbers inside of this array of memory so here are seven integers or in and see i have in this case sorted them just to make the numbers pop out as obviously smallest to largest but the catch would see is that if i were to ask you or if you were to ask the computer through code to. Find you the number 50 well obviously every human in this room just found it obviously right there because we kind of have this birds eye view of the whole memory at once but the computer ironically does not have that birds eye view of its own memory it can only look at each location one at a time so if you really were to do this like a computer you would kind of have to shield your eye and only look at one number at a time from left to right from right to left or in any order in order to find is the fifth. Actually there you don't can't just take a step back and boom it pops out at you so this is kind of analogous this array to being like a set of gym lockers or school lockers like this where the doors are actually closed by default the numbers are in there but the doors are closed which is say the computer and we can't actually look so we couldn't find yellow lockers but we did find red lockers here and so i propose that you think of these lockers on the stage here of which there are seven as well as representing an array and just so we have some terminology. That i've labeled these bracket zero bracket one bracket 2345 and six and the bracket notation recalls the new syntax from last week that lets you index into go to a specific spot inside of an array and notice that even though there are seven lockers i only counted as high as six but again that's just a side effect of our generally counting from zero so zero through six or zero through a minus one because if there are a equals seven lockers and minus one is six so that's the left bound. And the right bound respectively so suppose that we were to use the these lockers as representing a problem like we want to find an actual number behind these doors so this is actually a very common problem in the real world and you and i take for granted every day that big companies like google and microsoft and others like do this for us constantly glad to mention a doing something similar nowadays searching for information and we'll focus on some basics first that will lead us to more sophisticated algorithms ultimately. We're going to talk about fundamentally is this same picture from week zero and from week one and from week two where here is a problem to be solved so if for instance the input to this problem is an array of numbers in a ray of seven numbers i can't see them all at once but i'm looking for something like the number 50 ultimately i want to get back out i claim true or false like the number 50 is there or it is not that's one way of thinking about the search problem find me some piece of data if it's there otherwise tell me that it's not true or false. Respectively so the algorithm inside of this black box though is where we're going to actually have to do some thinking and actually figure out how best to find the number or the data we care about and even though we'll use numbers to keep things simple today you could certainly generalize this to web pages or contacts or any other type of information that are in some computer or database more generally so maybe to keep things interesting could we get how about two volunteers wow that was fast. Come on down and have one other volunteer over here of how about you come on down sure round of applause for our volunteers welcome come on over do you want to introduce yourself to the group like a few seconds hi i'm sam i'm not a is concentration so what are you do you know yet applied match of nice nice to meet you welcome. Hi i'm louis i'm from first room matthews i'm going to do econ with stats you're in matthews too i was in matthews too so matthew south of my god i was room 201 fifth floor all right so anyhow so we have louis and your name sam louis and sam so louis and i are going to step off to the side for just a moment because sam we have a problem for you to solve behind you feels a little bit like price is right but behind you are these seven lockers. And we'd like you to just find us the number 50 that's all the information you get but we'd like you to then explain how you go about finding it find us the number 50 and then tell us how you found it what was in there just so the audience knows yes yeah. Take money of that was 100 1 5 of i'm not lucky of i found it nice take it out and so people can believe all right wonderful so you found the 50 and now if you could explain i'll take that if you could explain what was your algorithm what was the step by step approach you took. Us i didn't really have one i thought i just started on one end and i went down because it wasn't in order or anything so i just kept going until i found it okay so that's actually pretty fair and in fact let's step forward here carters gonna very secretly kind of shuffle the numbers in a particular new arrangement here and so you really went from right to left and i dare say maybe going from left to right might be equivalent but could could she have done better could she have done better because that took 12345 steps could sam. Done better sure how of so you got lucky you could have found the number in one step although luck isn't really an algorithm it really isn't a step by step approach so i do another thought of interesting so you could have taken out all of the dollar bills sorted them put them back in and then you probably could have done something like the divide and conquer approach. No you weren't allowed to so that's that's fine but that would be a valid algorithm although it sounds very inefficient to do all this work just to find the number 50 because in doing that work she would have found the 50 once but that might actually be a reasonable solution if she plans to search again and again and again not just for seven numbers but maybe a lot of numbers maybe you do want to incur some cost up front and sort all the data as to is to find it faster but let's do this a little more methodically we'll step off to the side once more and just by convention if you want to go ahead and do we need this of. Of let's go from left to right yep and go ahead and show everyone the numbers just to prove that there's no funny business here 20 of 500 nice 10 so it doesn't sound like it's sorted either this time 5 nice and. 100 so close i know now we're just messing with you of and lastly very well done of so nicely done and so thank you so this is to say whether she goes from left to right or right to left like the performance of that algorithm just going linearly from side to side really depends on where the number ends up being and it kind of does boil down to luck and so that was kind of the best you could. Could do because i dare say had you gone linearly from right to left and go ahead to reset had you gone from right to left that time you would have gotten lucky so on average it might just kind of work out and so half the time it takes you maybe half as many steps half the number of lockers to find it on average because sometimes it's in the one end sometimes it's in the other end sometimes it's smack dab in the middle but we're going to give you the option now louie of knowing that it's sorted so we're not gonna we're gonna take away the microphone from you but stay on up here with us and you are now given the. That the numbers are this time sorted from smallest to largest left to right and might you want to take more of a divide and conquer approach here wait a minute what might you do as your algorithm louis well i think i know all the numbers right it's 1 5 10 20 50 so louis has some memory as we'll say of but assuming if i didn't have memory of assuming if you didn't have memory where would you start first i would probably start in the middle of go ahead go in the middle and what do you see. 20 20 of what does that mean now for you so now that means as soon as i know there's some numbers bigger i'll go to the right good so you can sort of tear the problem in half so to speak as per week zero skip all of the lockers on the left and now go where relative to these three relative to the middle of so maybe i don't know what's on the right hand side and so now it's 100 of nice so 50 must be between 20 and 100 so it must be this one indeed so a round of applause for louis for getting this right this time. We have some lovely parting gifts since we're using monopoly money so it's not actual money but this is the cambridge edition harvard square in all for both of you so welcome thank you so much so louis was actually getting particularly clever there when his first instinct was to just remember what were all the numbers and then sort of deduce where the 50 must obviously be so that's on us like ideally we would have completely changed the dollar amount so that he couldn't use that. Information but it turns out louis instinct there to figure out where the number should be and jump right there index into that exact location is actually a technique and it's a technique we'll talk about in future class classes where you actually do take into account the information and go right where you want it's an example of what will eventually call hashing so to speak in a concept called hash tables but for now let's try to formalize the algorithms that both of these volunteers kind of intuitively came up with first and second. And we'll slap some names on them so the first and i've hinted at this is what we would call linear search anytime you search from left to right or from right to left it's generally called linear search why because you're kind of walking in a line no matter which direction you're going but now for today is purposes let's see if we can't truly formalize what our volunteers algorithms were by translating them not necessarily to code yet but pseudo code see if we can't map it to english like syntax that gets the ideas across so i dare say the first alga. Even though she went from right to left then from left to right might look like this for each door from left to right she checked if 50 is behind the door as by looking at it if it were behind was behind the door then she returned true like yes this is the 50 that didn't happen on the first iteration though so she she moved on again and again and now notice the indentation here is just as important as it was in week zero notice that only at the very bottom of this algorithm do i propose returning. False but it's not indented inside of the pseudo code why well because if i had changed it to be this what would be the logical bug in this version of that algorithm yeah exactly if she had opened the first door found it to be the wrong number if it says else if it's not behind the door then return false that would erroneously conclude the 50 is not there even though it could certainly be among those other doors so this first. Version of the code where the returned false is sort of left indented so to speak and the very last thing you do if you don't previously return true that just makes sure that we're handling all possible cases but let's make this maybe a little more technical this is how a computer scientist or a programmer would likely express this instead instead of just drawing it in broad strokes it's actually fine to kind of steal some of the syntax from languages like a and actually use some of the indices or indexes like 0 1. 1 2 3 4 5 6 to represent the pieces of data we care about so this is a little more precise 4i like a variable i from the value 0 to a minus 1 so in the case of seven doors this is like saying 4i starting at 0 going up to 6 do the following if the number 50 is behind the doors array so i'm using array syntax even though this is technically still pseudo code if the i the location of my doors array. Has the number 50 return true otherwise if you do that again and again and again and total times and you still don't find it you want to return false so we introduced this is just an example of how you can start to borrow ideas from actual code to paint the picture even more precisely of what it is you want a colleague to do what it is you want your code to do ultimately by sort of borrowing these ideas from code and incorporating it into our pseudo code but what about. Us the second algorithm here the second algorithm whereby he took a divide and conquer approach starting in the middle and then going right and then going left well turns out this is generally called binary search by implying two because you're either going with the left half or the right half again and again this is literally what we've been talking about since week zero when i searched the phone book that too was binary search dividing and dividing and dividing in half and half so if we were to draw some pseudo code for this i would propose that we could do something like this. If 50 is behind the middle door then we got lucky just return true else if the 50 is less than the value at the middle door so if it's smaller than the middle door i want to search to the left so i can say search left half else if 50 is greater than the middle door i want to search to the right and i think that's almost everything right is there a fourth possible case what else could happen. Good so taking into account that if there are no doors left or no doors to begin with we better handle that case so that we don't induce one of those spinning beach balls so that the computer doesn't freeze or crash there's really four possible scenarios in searching for information it's either in the middle or to the left or to the right or it's just not there at all and so i sort of slipped that in at the end because technically that's a question you should ask first because if there's no doors there's no work to be done but logically this is the juicy piece. Parts the other three questions that you might ask yourself so this then might be the pseudo code for binary search and we could make it more technical and this is where it kind of escalates quickly syntactically but i'm just using the same kind of syntax if doors in my pseudo code represents an array of doors well then doors bracket middle is just a pseudo code like way of saying go to the middle door in that array and then notice else if 50 is less than that middle value then search doors bracket zero so the left most one. Through doors middle minus one so you don't need to waste time researching the middle door so i say middle minus one so that i scotch over slightly to the left so to speak else if 50 is greater than the value at the middle door then you want to search one over to the right so middle plus one among those doors through the last door which is not a because we start counting at zero but a minus one and the rest of the algorithm is the same this is just a little more precise and i dare say when writing a. Program in a or any language like honestly starting in pseudo code like this will generally make it much easier to write the actual code so in fact in this and future problem sets do get into the habit especially if you're struggling getting started just write things out in english and maybe high level english a little more like this then as a version to go in with your keyboard or paper pencil and make it a little more precise using some code like syntax and then i dare say in version three you can now translate this pretty much verbatim. The only headache is going to be rounding issues with integers because if you divide an integer and you get a fraction it's going to truncate so all that kind of headache but you can work through that by just thinking through what's going to get truncated when you round down or up as a solution any questions though on this pseudo code for either linear or binary search as we've defined them linear or binary search no all right well let's consider then a bit more formally a question that will come to mind. Back to in future classes as well what is the running time of these algorithms what is that is to say the efficiency of these algorithms and how do we actually measure the efficiency of an algorithm is it with a stopwatch or with some other mechanism well i propose that we think back to this picture here whereby this again was representative of both the phone book example from week zero and theoretically bug aside the attendance counting algorithm from earlier today whereby this same green line theoretically. Represents how much time it should have taken us as a group to count ourselves why because if maybe another class comes in and doubles the size of the number of humans in this room no big deal that's just one more step or one more iteration of the loop because half of the people would anyway sit down so this green algorithm still represents the faster theoretical algorithm today and so recall that we described these things more mathematically as a so this was one page at a time or one person at a time. This was two people or two pages at a time so it's twice as fast so if a is the number of people or pages a divided by 2 is the total number of steps and then this one got a little kathy but log base 2 of a and log base 2 of a just means what is the value when you taken and divide it in 2 by 2 again and again and again and again until you're left with just one page or one person standing but in the world of running times it turns out that being this precise is not that intellectually interesting. And it sort of devolves into lower level match it's just not necessary when having discussions about the efficiency of an algorithm or even code that you've written so generally a computer scientist when asked what's the running time of your algorithm or what's the efficiency of your algorithm or more generally how good or bad is your algorithm they'll talk about it being on the order of some number of steps this is a phrase you'll hear increasingly in computer science where you can kind of wave your hand at it like he the lower level details don't matter that much all you care about in broad strokes are. Are certain numbers that will add up the most and in fact when computer scientists talk about the efficiency of algorithms they tend to throw away constant factors so literally numbers like two that might be dividing here or a base here so for instance these two algorithms to a computer scientist would sort of be the same like yeah it's technically twice as fast but look at the lines i mean they're practically the same and this one here too log base two sure but if you remember from a match class you can change the base. Of any logarithm from one number to another pretty easily so let's just generalize it as log of a it doesn't really matter fundamentally what the numbers actually are and honestly if we zoom out slightly so that they axis and the a axis get even bigger honestly these first two algorithms really do start to resemble each other closer and closer and i dare say in your minds eye imagine zooming further and further and further out like that red and yellow line are pretty much once a is large enough going to be. Be functionally the same like they're practically the same algorithm but this one is still doing amazingly because it's a fundamentally different shape so this is to say when a computer scientist talks about thinks about the efficiency of algorithms we just throw away the constant terms that when a gets really large just don't seem to matter as much they don't add up as much or fundamentally change the picture in a case like this so what i'm describing here with this capital letter of has a technical term this is called big of notation and this is omnipresent in computer science. And often rears its head even in programming specifically when talking about the design of some algorithm and this is a little cheat sheet here on the screen now very often algorithms that you write or you use will be describable as being on the order of one of these running times son is just representative of the number of things number of people number of pages whatever it is you're actually doing in code so the mathematical formulas inside of the parentheses. Describe as a function of the size of that input how fast or slow the algorithm is going to be so this algorithm in the middle here big of of a so to speak means that it takes linear time in other words so my first algorithm 1 2 3 4 or my first algorithm in week 0 1 2 3 4 that was a linear search the number of steps it takes is on the order of a because if there's a pages in the worst case like john harvard all the way at the end of the phone book so it takes. Men steps in this case it's always going to take men steps to count you all because if i want to point at each and every one of you that is always going to take men steps so big of represents an upper bound on the number of steps that you might be counting and so we often use it to consider the worst case and the worst case john harvard or whoever might be all the way at the end of the phone book so that linear search is on the order of a but what about a squared this means like a people doing a things so for instance and we won't do this. But if we were to ask you again to stand up and shake everyone is hand in the room not good for health nowadays but it shake everyone is hand in the room how many handshakes would there be well if there's a of you and you've got to shake everyone else is hand that's technically a times a minus 1 let's throw away the minus 1 that's a times nor a squared handshakes like that's a lot of handshakes and so the running time of shaking everyone is hand in the room to introduce yourself would be on the order of a squared. At the other end of the spectrum the faster end big of of one doesn't mean that an algorithm takes literally one step it could take two steps or three or even 1000 steps but what it means is it's a constant number of steps so it doesn't matter how many people are in the room this describes something taking just one step us total or a constant number of steps total so for instance earlier when everyone stood up at the same time that was constant time because if we had twice as many people come into the room. It's not going to take us twice as long to stand up if everyone stands up at the same time that would be a constant time algorithm so this is linear this is constant if you want to get fancy this is quadratic this is logarithmic and this is a log nor there's other fancier terms we can give it as well but for now it's just a common list of running times that we might apply to certain algorithms so linear search i claim is in big of of a because it's going to take in the worst case a steps what about binary search. How many steps does binary search take on the order of according to this chart yeah log a yeah because no matter what with binary search you're dividing in half half half but in the worst case it might be in the last door you check but you only took log a steps to get there but it still might be the last one you check so binary search indeed would be on the order of log a but sometimes you do get lucky and we saw with our volunteers that sometimes you get lucky. Can get lucky and just find things quicker so we don't always want to talk about things in terms of an upper bound like how many steps in the worst case might this algorithm take sometimes it's useful to know in the best case how few steps might an algorithm take so for that we have this capital greek omega which is another symbol in computer science and whereas big of represents upper bound omega represents lower bound and it's the exact same idea it's just a different symbol to represent a different idea the opposite in this case. Here but when you use the omega symbol that just means that this algorithm might take as few as this many steps for instance in the very best case so by that logic if i ask about linear search our first demonstration with the lockers let's consider the best case how many steps might it take to search a lockers using linear search in the best case you get lucky so i heard it yeah just one step so we could say that linear search is an omega of one so to speak what about binary. Search if you've got a lockers in the best case though how few steps might it take us again one because we might just get lucky and boom it happens to be right there in the middle so you could say that both linear search and binary search are in omega of one now by contrast my counting my attendance algorithm the first one i proposed 1 2 3 4 5 6 7 i claimed a moment ago that that's in big of of a because if there's a people in the room i've got to point at everyone but equivalently if there's a. People in the room and i have to point at everyone what's the fewest number of steps it could take me to take attendance using this linear approach so still a right unless i guess which is not an algorithm like if unless i guess i'm not going to get the right answer so i kind of have to point at everyone so in both the best case and the worst case some algorithms still taken steps and for this we have what we'll call theta notation whereby if big of and omega happen to be the same which is not always the case but can be then you can say that. That algorithm is in theta of such and such so my attendance taking algorithm the very first 1234 all the way on out to a would be in theta of a because in both the best case and the worst case it takes the same number of steps as per my big of and omega analysis now there is a more formal mathematical definition for both of these and if you take higher level computer science you'll go more into the weeds of these ideas but for now big of upper bound omega lower bound questions. On the the symbology don't be a tool in our tool cat no okay so with that said let's see how we might translate this to actual code and something that makes sense now using see you not so much new syntax but applications of similar ideas from last time so for instance let me actually go over to search dot a and in search dot a i'm gonna go ahead and implement the idea of linear search very simply using integers initially. So to do this let me go ahead and give myself the familiar is 50 doth so that i can ask the human what number to search for then let me go ahead and include standard i owe doth so that i can use print of and the like then i'm gonna go ahead and do in main void without any command line arguments because i'm not gonna need any for this particular demonstration and someone asked about this a while back if i want to declare an array of values but i know in advance what the values are there is a special syntax i can use which is this if i want a whole bunch of numbers. But i want those numbers to be stored in an array i can store them in using these curly braces and i'm going to use the same numbers as the monopoly denominations that we've been playing with and i'm just going to put them in sort of random order but i'm going to deliberately put the 50 all the way at the end just so that i know that it's going to try all possible steps so big of of a ultimately now let's go ahead and ask the user for a value a and we'll use get int and just ask the user for a number to search for be it 50 or something else and then here's how i might implement. In code now linear search translating effectively the pseudo code from last time for int i equals 0 i is less than 7 i plus plus and then inside of this loop i can ask a question if the with number in the numbers array so numbers bracket i equals equals the number a that i care about well this is where i could just declare return true where return false here i'm going to go ahead and just use a print statement and i'm going to say found backslash. And just to know visually that i found the number and else i might do something like this else if that's not the case i'll go ahead and print out us not found backslash a all right so let me zoom out for just a moment here's all of my code any concerns with this implementation of what i claim is now linear search any concerns with what i claim is linear search yeah. Exactly if i search the first number and it's not found it's gonna say not found but it's gonna keep saying not found not found not found which might be fine but it's a little stupid i probably want to know if it's found or not so i've made that same mistake that i called out earlier like the else is not the alternative to not finding the number in that first location it's the final decision to make when i haven't actually found the value so i think what i want to do is get rid of this else clause and then at the. Outside of this loop i think i want to conclude print of not found but here too there's a new bug that's arisen there's a new bug even though i fixed the logical error you just described what symptom are we still going to see yeah now it's going to always print not found even when i have found it because even once i found it and i finish going through the array it's still going to assume that i got to the bottom and therefore it's not found so i need to somehow. Exit out of main prematurely if you will and recall that last week we also introduced the idea that main all this time does actually return a value in integer by default it's secretly been zero anytime a program exits it just returns zero and exit status of zero but we do now have control over that and so a convention in a would be that when you want your main function to end prematurely if so you can literally just return a value and even though this feels a little backwards this is just the way it is. Return zero to indicate success and you return any other integer to indicate failure so by convention people go to one and then two and then three they don't think too hard about what numbers to use but in this case i'm going to go ahead and return one if i do get to the bottom of this file so now if i open back up my terminal window i run make search no syntax errors dot slash search i'm going to be prompted for a number let's go ahead and search for the number 50 and i should see found meanwhile if i run it again. Again dot slash search and i search for the number 13 that should be not found so i claim that this is now a correct implementation of linear search that's gone from left to right looking for a number that may or may not be there any questions on this version of the code here yeah return 0 indicates success when doing it from main in particular and that's backwards only in the sense. That generally zero is false and one is true but the logic here is that if something if the program works correctly that's zero but there's an infinite number of things that could go wrong and that's why we need one and two and three and four and all the way up other questions yes correct when you return zero or return any value from maine wherever. It is in your code the program will effectively terminate right then and there no additional code will get executed at the bottom of the function you'll effectively exit out just like in a normal function that isn't made when you return a value it immediately exits that function and hands back the value yeah so return one is just me being pedantic at this point because i'm frankly not gonna really care what the exit status is of this program but once i've introduced the idea. Of manually returning zero on this line 14 to indicate success it stands to reason that i should also return a different value when i want to indicate failure and so even though this does not functionally change the program it will still work it will still print the same things correctly it's a lower level detail that programmers teaching assistance testing software might appreciate knowing what actually happened in the program underneath the hood all right so what about. So it turns out with strings we're going to have to be think a little harder about how best to do this so let me actually go ahead and do this let me go ahead and get rid of much of this code but transition to a different type of array this time an array of strings and i'm going to call the array strings itself plural just to make clear what's in it instead of numbers i'm going to use the square bracket notation which just means i don't know at the moment how many elements it's going to have but the compiler can figure it out for me and in the spirit of monopoly let's go ahead in our curly braces do something like this. Battleship is going to be one of the strings boot is going to be another cannon is going to be a third iron is going to be the fourth thimble if you ever played monopoly you know where these are coming from and top hat for instance so this gives me 123456 i could write the number six here and the compiler would appreciate it but it doesn't matter the compiler can figure it out on its own just based on the number of commas and this also ensures that i don't write one number to the left and then discount on the right. So omitting it is probably in everyone is benefit now let's do this let's ask the user for a strings using get string instead of get int for some string to search for then let's go ahead and do the exact same thing for int i equals 0 i is less than 6 which is technically a magic number but let's focus on the searching algorithm for now i plus plus and then inside of this loop let's do this if strings bracket i. Equals equals a then let's go ahead and print out just as before quote unquote found backslash a and proactively return 0 this time and if we don't find it anywhere in the loop let's go ahead and return 1 at the very bottom before which we will print not found backslash a so it's the exact same logic at the moment even though i've changed my its to strings let me go ahead and open up my terminal window now do make search again and see. So good let me now go ahead and do dot slash search and let's go ahead and search for how about top hat so we should see found huh all right not found all right well let's do dot slash search again how about thimble maybe it's because it's just two words no thimble is not found either dot slash search let's search for the first one battleship enter still not found let's search for something else like cat not found what is going on. Because i'm pretty sure the logic is exactly the same well it turns out in a this line here currently line 11 is not how you compare strings if you want to compare strings in a you don't do it like you did integers you actually need another technique altogether and for that we're going to need to revisit one of our friends which is string a which is one of the header files for the string library that we introduced last week that has in addition to functions like st lang which gives you the length of a string. It also gives us as per the documentation here another function that will start to find useful here succinctly named stir comp for string compare and stirring compare will actually tell us if two strings are the same or not it will indeed compare them and if i use this now let me go back to my code here and see what i might do differently in my if i go back into my code here and change this value instead of using strings bracket i equals equals a let's do stir compare and i read. The documentation earlier so i know that it takes two arguments the first and the second string that you want to compare so strings bracket i and then a which is the string that the human typed in but somewhat weirdly what i want to check for is that stir compare returns zero so if stir compare when given two strings is input strings bracket i and a returns a integer zero that actually means the strings are. So let's try this let me do make search again huh what did i do wrong here a whole bunch of errors popped out what did i do wrong yeah yeah so i didn't include the very header file we're talking about so again it doesn't necessarily mean a logical error it just means a stupid error on my part i didn't actually include the header file so let me go back and actually do that up at the top in addition to cs50 hand standard i of let's also include string a let me clear my terminal and do make search again crossing my fingers. That time it worked and now if i do dot slash search and search for top hat like before now thankfully it is in fact found if i do it once more and search for battleship now it's in fact found if i do it once more and search for cat which should not be in there that is not in fact found so now just intuitively even if you've never done this before why might it be valuable for this function called st comp to return zero if the strings are equal. As opposed to a simple boolean like true or false which might have been your intuition when you compare two strings what are the possible takeaways you might have from comparing two strings it's not just that they're equal or not of so maybe if the as ii values are the same that might imply indeed literal equality but something else a nice. Certainly are very much in the habit of sorting information whether it's in a dictionary in our contacts in a phone book in any such technology and so it's often useful to be able to know does this string equal another sure but does this string come before another alphabetically or maybe after another alphabetically so sometimes you want functions to give you back three answers but equals equals alone can only give you true or false yes or no and that might not be useful enough when you're trying to solve some problem involving strings so it turns out. Stir compare actually compares the two strings for equality but also for what's called playfully as ii be title order so not alphabetical order per be but as ii be title order where it actually compares the integer values of the letters so if you're comparing the letter a it's gonna compare 65 against some other letters integer value and as ii be title value so we're not doing any form of sorting here so it's sort of immaterial but as per the documentation i do know that stir compare return zero. If two strings are equal and a little teaser for next week it turns out when i was only using equals equals to compare strings bracket i and a i was not comparing the strings in the way that you might have thought and if you have programs in java or python before equals equals is actually doing something different in those languages than it is actually doing in a but more on that next week for now just take on faith that stir compare is indeed how you compare two strings so let's actually put this. Into play with some actual some additional code let me propose that we implement a very simplistic phone book for instance let me go ahead and implement here how about in a new file instead of search dot a let's actually do phone book dot a and in this phone book i'm going to go ahead and include the same header file so is 50 doth so i can get input standard i of doth so i can use print deaf string doth so that i can use stir compare let me give myself a main function again. Without command line arguments for now and let me go ahead now and store a proper phone book which has some names and some actual numbers so let's store the names first so string names is going to be the name of my array and let's go ahead and store carters name how about my name and maybe john harvard for phone book throwback then let's go ahead and give me another array called numbers wherein i'll put our phone number so 617 495 1000 for carter 617 495 1000 for. Technically directory assistance here and then for john we'll give him an actual one so it's actually going to be 949 468 2750 you're welcome to text or call john when you want whoops and just for good measure let's go ahead and put our country codes in here plus 1 even though at the end of the day these are strings so indeed notice i'm not using an integer for these values i kind of sort of should but here's where data types in a and programming more generally. Sometimes mislead you even though we call it obviously a phone number it's probably best to represent it generally as strings in fact so that you can have the pluses you can have the dashes so that it doesn't get too big and overflow an integer maybe it's an international number for which there's even more digits you don't want to risk overflowing a value and in general the rule of thumb in programming is even if in english we call something a number if you wouldn't do match on it ever you should probably be storing it as a string not as an integer and it makes no. Logical sense to do match on phone numbers per be so those are best instinctively left as strings and in this case even more simply this ensures that we have pluses and dashes stored inside of the string all right so now that i have these two arrays in parallel if you will like i'm assuming that carters name is first so his number is first davids name is second so his number is second johns is third and thus third so let's actually search this let's ask the user for how about a name using. Get string and this will be a name to search for in the phone book just like we did in week zero let's do for int i equals zero i less than three again the three is bad practice i should probably store that in a constant but let's keep the focus for today on the algorithm alone i plus plus then in here let's do if how about names bracket i equals equals name typed in but wait a minute i'm screwing this up again. What should i be using here stir compare again so let's do stir compare names bracket i comma name which came from the user and if that return value is zero then let's go ahead and print out just like before found backslash and but you know what we can do something more interesting let's actually print out the number so i didn't just find something i found the name so let's actually plug in that persons corresponding number so now it's a more useful phone book or contacts app where i'm going to show the human not just found. But found this specific number then i'm going to go ahead and just before and return zero to indicate success and if we get all the way down here i'm going to go ahead and say not found and not print out any number because i obviously haven't found one and return one by convention to indicate failure so let me open my terminal window let me do make phone book enter so far so good dot slash phone book let's search for carter enter found his number let's do it again dot slash phone book david found it. Let's do it one more time for john found it and just for good measure let's do one other here like eli enter not found in this case all right so it seems to be working based on this example here but now we've actually implemented the idea of like a proper phone book but does any aspect of the design of this code even if you've never programmed before is 50 does anything rub you wrong about how we're storing our data the phone book itself these names. And numbers does anything rub you the wrong way yeah back yeah really good observation i'm separating the names and the numbers which indeed it looks a little bit weird and there's actually this technical term in the world of programming which is code smell where like something smells a little off about this code in the sense that like this probably doesn't end well right if i add a fourth name a fourth number. A fifth name a 50th name and number like at some point they're probably going to get out of sync right so like there's something awry about this design that i shouldn't decouple the names from the number so something kind of smells about this code so to speak and anytime you perceive that in your code it's probably an opportunity to go about improving it somehow but to do that we actually need another tool in the toolkit and that is again this term that i've used a couple of times data structures like arrays have been the first of our data structures and they're so simplistic it just means storing things back to back to back. In memory but it turns out a and a little bit of new syntax but there's not a lot of new syntax today a little bit of new syntax today will allow us to create our own data structures our own types of variables largely using syntax we've seen thus far so to do this let me propose that in order to represent a person in a phone book well let's not just implement them as a list of names and a list of numbers wouldn't it be nice if chad a data type actually called. Person because if it did then i could go about creating an array called using the plural zed form people containing my people in my phone book and maybe a person has both a name and a number and therefore we can kind of keep everything together so how can i do this well what is a person well a person really in this story is a person has a name and a person has a number so can we create a new data type that maybe has both of these together. By using one piece of new syntax today which is just this here using what's called a struck we can create our own data structure that actually has some structure in it it's not just one thing like a string or an int maybe it's two strings maybe it's two its maybe it's one of each so a structure can be a variable that contains any number of other variables so to speak and type def is a cryptic keyword that just means define the following type invent the following data type for me and the syntax is a little weird. But you say type def struck curly brace inside of the curly braces you put all of the types of variables you want to associate with this new data type and then after the curly brace you invent the name that you want to give it and this will create a new data type in a called person even though no one thought of this decades ago when a was created alongside of the its and the floats and so forth so how can i actually use this well it turns out that once you have this building block of creating your very own. Data structures i can go back into my code and improve it as follows in direct response to your concern about it seeming not ideal that we're decoupling the names and the numbers now it's going to look a little more complicated at first but it will scale better over time so within my code here i'm going to go ahead and essentially type out exactly that in the same data type so define a structure that has inside of it a string called name and a string called number and let's call this thing a. So these new lines copied and pasted from the slide a moment ago just invent the data type called person so the only thing we need today is the syntax via which we can set a persons name and number like how can we access those values so to do this i'm going to go ahead and erase the hard coded arrays that i had before and i'm going to give myself one array of type person called people with room for three people so this seems like a bit of a mouthful but the new data type is called person. Gray name is called people which in english is weird i mean it could also call it persons to make it a little more parallel but we call them people generally and i want three such people in my phone book now how do i actually initialize those people well previously i did something like this names bracket zero and then i did numbers bracket zero well it's a similar idea i do people bracket zero but if i want to set this persons name the one new piece of syntax today is a period a literal dot operator. That says go inside of this person and access their name field or their name attributes and set it equal to quote unquote carter then go into that same person but go into their number field and set that equal to plus 1617495 1000 then and i'll just separate it with white space for readability go into people bracket one set their name into mine david let's go into people bracket one number set that equal to the same since we're both. Both available through the directory so 617 495 1000 and then lastly let's go ahead and do people bracket two dot name equals quote unquote john and then people bracket two dot number equals quote unquote plus 1 949 46a 2750 fix my dash semicolon and now i think i can mostly keep the rest of the code the same because if i'm searching. For this persons name i think the only thing i want to change is this because i don't have a names array anymore so what should i change this highlighted phrase to in order to search the with persons name what should this be yeah people bracket i dash name because the whole point of this loop is to iterate over each of these people one at a time so people bracket i gives me the with person first people zero people one people two. I want to check that persons name and compare it against whatever the human typed in now i can do exactly that but i have to change the output to be people bracket i dot number in this case so i've added a little bit of complexity and granted this is not going to be the way long term you create a phone book odds are we're going to get the phone book with a loop of some sort we're going to use a constant so i know how many people i have room for for demonstration sake i'm just typing everything out manually but i think logically now we've achieved the same thing. So let me do make phone book for this new version no syntax errors dot slash phone book let's search for carter enter and there indeed is his number let's go ahead and search for david there's my number and lastly let's search for john his number and again we'll search for someone we know is not there eli and eli is not found so what we've done is try to solve this problem of introducing a brand new data type that allows us to represent this custom data that you and i just created and that is by using the structure of the data. Keyword to cluster these things together and the type def keyword to give it a brand new name that we might like now as an aside when it comes to styling your code you'll actually see that style 50 and similar tools will actually put the name of the data type on the same line as the closing curly brace just sort of a curiosity that's fine even though i wrote it the first way for consistency with scratch and our prior examples this is the right way in styling it any questions now on this data type yeah. The question is can you have to assign both the name and the number when creating a person or can you only get away with doing signing one of them you can but that's going to be one of those so called garbage values typically and so there's just going to be some bogus data there and unless you are so careful as to never touch that field thereafter you probably run the risk of some kind of bug even a crash in your code if you try to access that value later even though you've never initialized it. So yes it's possible but no do not do that other questions all right well up until now now that we have the ability to sort of represent more interesting structures up until now we've sort of assumed that in order to get to binary search we have a phone book that someone already sorted for us for our second demonstration with our volunteers we assumed that someone carter in that case had already sorted the information for us it was proposed by the audience that well what if we sort the information first and then go find the number 50. That invited the question even early on well how expensive is it to sort how much time and money and inefficiency do google and microsoft and others spend to keep their data and our data sorted well let's consider what the problem really is if this is how we represent any problem the unsorted data that we might consume by typing things in randomly to a search engine or crawling the internet or just adding context in any old order to our phone is arguably unsorted certainly not alphabetically sorted by default but we want to get it sorted. Somewhere in here in this black box we need a set of algorithms for actually sorting information as well for instance if we have these integers here unsorted 7 2 5 4 1 6 0 3 effectively random the problem of sorting of course is to turn it into 0 1 2 3 4 5 6 7 instead and there's a bunch of different ways to do this but before we do that i think it's probably time for some brownies so let's go ahead and take a 10 minute break and we'll see you in 10 all right we are back and where we left off was this cliffhanger. We've got some unsorted numbers we want to make them sorted how do we do this and at the risk of one too many volunteers could we get eight more volunteers of wow of overwhelming of how about one two three four how about all three of you of five six seven eight of eight come on in all right one from each section all right come on down. All right come on down thank you and if you all could grab a number here so you'll be seven stand on the left there if you could all right you'll be number two stand to his left of keep coming of yeah of here we go here we go of zero and three of so let's just make sure that this is. They match what we got there good so far of so we have eight volunteers here an array of volunteers if you would this time we've used eight rather than seven we deliberately had seven lockers just so that the divide by two match worked out that was very deliberate that there was always a half a middle a middle a middle in this case it doesn't matter because we're going to focus on sorting but first how about some introductions from each group i'm rebel a i'm a first year in penny packer and i'm thinking about studying environmental science and public policy nice. I'm maria i'm also in penny packer i'm a first year and thinking of studying bioengineering wonderful my name is heron lee i'm a freshman in matthews i'm playing on studying applied mathematics nice matthews my name is emily i'm a first year in canada and i'm still deciding what to study there my name is tanya i'm a first year from toronto and i'm planning on studying in econ and is nice my name is teddy i'm first year in her but and i'm playing on concentrating in computer science with. Lenny. All right that was very good so yes for sure of and let's see what was your algorithm i just kind of found the person that was like one lower one higher so i like looked at him he had two so i knew i'd be on his left and then she had three so i told her come to my right and then i knew he had five so of now he's pretty clever. And how about your algorithm same thing looked for the number that was lower and higher and found the middle of interesting because i think from the outside view it all seemed very organic and things just kind of worked themselves out which is fine but i dare say what you guys did was probably a little hard for me to translate into code so let me propose that we take two passes at this if you could reset yourselves to be in that order from left to right which is just the exact same sequence just so that we're starting from the same point each time 17 very interesting. All right so let me propose this we can approach sorting in a couple of different ways but it needs to be methodical like it needs to translate ideally to pseudo code and eventually code so as much as we can quantize things to be step by step i think the better this will scale overall especially when there's not eight people but maybe there's 80 people or 800 because i dare say that if we had everyone in the room sort themselves if they were all handling a number like that probably wouldn't have worked out very well it probably would have taken forever because there's just so much more data so let's be a little more methodical. Methodical so for instance i don't have a birds eye view of the numbers just as before because even though we don't have doors in front of our volunteers they're effectively lockers to and the computer or the human in my case can only look at one door at a time so if i want to find the smallest number and put it where it should go on the left i can't just kind of take a step back and be like okay obviously there's the one i have to do it more methodically so i'm going to check here seven at the moment this is actually the smallest number i've seen so i'm going to make mental note of it okay two i see now i can forget about the seven because two is. Clearly smaller five i don't need to remember it for i don't need to remember it one okay that's clearly smaller have i found my smallest number not even because there actually is a zero so i should go through the whole list but i will remember that my smallest element is now one six is not smaller of zero is smaller so i'll remember this three is not smaller and so now our volunteer for zero was what was your name marianne where should we put you clearly so there but what's your name again elias in the way. So we could have mary ellen and mary ella just go to the right of eli but that's kind of cheating right because if this is an array recall that they are contiguous but there could be other stuff in memory to the left and to the right so that's not quite fair we can't just have the luxury of putting things wherever you want but eli you're not even in the right order anyway so why don't we just swap you to so mary ella and eli swap but now i've taken one bite out of this problem i've coincidentally made it a little better by moving eli closer to where he. Is but you know what he was in a random location anyway so i don't think i made the problem any worse fundamentally now i can do this again and i can shave a little bit of time off of it because i don't need to revisit marie a because if she was the smaller and i've already selected her from the array i can just move on and take one fewer bites this time around so two is the smallest number not five not four okay one is the smallest number so i'm going to remember that as with a mental variable 673 okay one is the smallest so let me select number one. And we're gonna have to evict you which is making the problem slightly worse but i think it will average out and now zero and one are in the right place so now let me do this again but faster so five okay 42 is the smallest 673 okay two let's put you where you belong evicting five now i can skip all three of these volunteers okay four is the smallest nope nope nope three you're the smallest let me evict four all right and now let me move behind in front of these volunteers five six. Come on back all right and now let's select 675 of come on back of no cheating you lie of and then let's see 576 of 6 come on back of now you have to move and now we've selected in turn all of the numbers from left to right and even though that did feel slower i was doing it a little more verbally as i stepped through it but i dare say we could translate that probably more to code why because there's a lot of looping through it and probably a lot of conditionals just asking the question. Is this number smaller than this one or conversely greater than this other one all right let's do this one more time if you guys could reset yourselves to this ordering all right so we again have 7 2 5 4 1 6 0 3 good so how about this i liked the intuition that they originally had funny enough whereby they just kind of organically looked to the person to the left and to the right and kind of fixed the problem so if they were out of order they just kind of swapped locally adjacent to the person. To each other so let's try this so seven and two you're clearly out of order so let's swap just you two seven and five you're out of order let's swap you two seven and four let's swap you two seven and one let's swap you two seven and six let's swap you two seven and zero swap you two seven and three swap you two of that was a lot of swapping but notice what happened i'm not done clearly it's not sorted yet but i have improved the situation how who is now definitely in the right place. So seven or eli has wonderfully like bubbled all the way up to the top of the list so to speak now i can actually skip him moving forward so that takes one bite out of the problem let's do this again two and five are of five and four let's swap over there thank you five and one let's swap five and six are good six and zero let's swap six and three let's swap and we don't have to worry about eli and now what's your name again harris we don't have to worry about him either as well so now i can go back to the beginning. It feels like i'm going back and forth a lot that's of because the problem is still getting better and better i'm taking a bite out of it each time 2 and 4 are good 4 and 1 let's swap 4 and 5 are good 5 and 0 swap 5 and 3 swap and now these three are in the right place let's do it again 2 and 1 a here we go let's swap 2 and 4 of 4 and 0 swap 4 and 3 swap now these four of 1 and 2 you're good 2 and 0 swap 2 and 3 you're good you're good of now 1 and 0. Swap one and two and now zero and one a round of applause if we could for our volunteer so if you want to put your numbers on the tray there we have some lovely super mario ores today which maybe drives a lot of the volunteerism but here we go thank you all so much and maybe carter if you can help with the reset all right here we go this is yes all set thank you very much thank you thank you guys. So to recap thank you yes to recap let's actually formalize a little more algorithmically what we did and i deliberately kind of orchestrated things there to show two fundamentally different approaches one where i kind of selected the element i wanted again and again on the basis of how small it was i looked for the smallest and the next smallest and so forth the second time around i took a different approach by just fixing local problems but i did it again and again and again until i fixed all of the minor problems. Problems and frankly what they did organically at the beginning was probably closer to the second algorithm than the first even though i'm not sure they would write down the same pseudo code for it the first algorithm we executed is actually called selection sort and i deliberately use that vernacular of selecting the smallest element again and again to evoke this name of the algorithm so for instance when we had these numbers here initially unsorted i kept looking again and again and again for the smallest element and i don't know. Rory what the smallest number is until i go through the list at least once then i can pluck out the zero i then go through the list a second time to pluck out the one a third time to pluck out the two now this assumes that i don't have an infinite amount of memory because even though i kept repeating myself looking for the next smallest element next smallest element i propose that i only keep track of one number at a time one variable in my mind which was the smallest element i have seen thus far if i used more memory. I could probably remember from the first pass where the two is where the three is but that's a different algorithm it would take more space more memory i was confining myself to just one variable in my approach so here might be the pseudo code for what we'd call selection sort the very first algorithm that we all did together not organically but more methodically as a group i would propose that we use some syntax from a when we talk about the loop and say for i from zero to a minus one now why is that well if there were in people. Or eight zero through seven are the indexes or indices of those humans on stage from left to right so what did i have myself do find the smallest number between numbers bracket i and numbers bracket a minus one so when the iteration when the loop starts at zero this is literally saying between numbers bracket zero and numbers bracket a minus one so from the far left to the far right find me the smallest number. Then swap that number with numbers bracket i so that's why we evicted the person all the way over to the right or your left the very first time and then the next person and the next person and so forth so this is an algorithm that has us go back and forth back and forth iteratively selecting the smallest element so if we generalize this now not away from eight people to like a people you can think of them as representing an array aka doors like this where the leftmost one is zero the rightmost one is zero. Is a minus one second to last is a minus two and so forth if we don't know or care what end specifically is so how do how many total steps does selection sort perhaps take and let's make this a little more real here let me actually open up for instance a quick visualization here and on the screen here you'll just see now an artist rendition of an array of values whereby tall purple bars represent big integers and short purple bars represent small integer so the idea of any sorting algorithm. Here as visualized is to get the small bars on the left and the big bars on the right and this is a nice handy tool that lets you play around with different algorithms so here is selection sort that i've just clicked in pink again and again is the equivalent of me walking through the volunteers looking for the next smallest element and as soon as i found them i swapped them into their left most location evicting whoever is whoever there in order to gradually sort this list from left to right and so as you can see here it holds very briefly in pink. Whatever the currently smallest element it is found is that's the analog of like me pointing to my head whereby it's constantly comparing comparing comparing looking for the next smallest element now i'm kind of stalling because i'm running out of like intelligent words to say but that is to say this algorithm feels kind of slow like it seems to be doing a lot of work where is the work coming in like what is it doing a lot of specifically yeah yeah it keeps going back and forth and back and forth and even though it's showing. Shaving a little bit of time right because it doesn't have to stupidly go all the way back to the beginning and i was saving myself a few steps like it's a lot of cyclic to again and again and again and put another it's a lot of comparisons again and again and some of those comparisons you're doing multiple times because i only remembered one element at a time in my head so i have to kind of remind myself on every pass which is smallest which is smallest so this invites the question how fast or how slow or equivalently how efficient or inefficient is. Something like us bubbles selection sort well let's actually consider how we could analyse this as follows so if we have a numbers that we want to sort how many comparisons do we do the first time well if there's a numbers you can only make a minus one comparisons why because if we have eight people here and we started with whoever is all the way over here we compare this person against seven others a minus one if a is eight so the first pass through the list. Made a minus one comparisons but that put the smallest number zero in place the second time i walked across our eight volunteers i didn't need to walk in front of all eight i could shave off a little bit and do seven of them then six then five then four so if i were to write this out roughly mathematically i could do this a minus one plus a minus two plus a minus three plus dot dot dot all the way down to my very last comparison at the end of the list now this is the kind of thing that typically in like high school you'd look at the back of the match book or physics book that's got a little. For all of the us formulas that add up this series here let me just stipulate adds up to this and times and minus one divided by two so no matter what and is this formula captures that series that summation of all of those values so that is how many steps i took again and again and again when implementing selection sort for eight people so of course let's multiply this out so this is like a squared minus a all divided by two let's do it out a little bit more that's a squared divided by two. Minus a over two and now we're back into the territory of running times like how many steps does this algorithm take how many comparisons are we making now a squared seems like the biggest term it's the dominant term in other words as a gets large not eight but 80 or 800 or 8000 or 8 million squaring that is going to make a way bigger difference than just doing like a divided by two and subtracting that off similarly just dividing even this quadratic formula by two like yes it's going to happen. Have it literally but that's kind of a drop in the bucket as end gets larger and larger and larger it's still gonna be a crazy big number so computer scientists would typically wrap this in some big of notation and say okay okay selection sort is on the order of a squared that's not a precise measurement but it's on the order of a squared because it's making so many darn comparisons not unlike everyone shaking everyone else is hand like i proposed verbally earlier it's a lot of work to get that done so selection sort is on the order of a squared steps. And that's kind of a slow one that's what is at the top of my cheat sheet earlier when i proposed a ranking of some common running times there's an infinite number of them but those are some of the common ones so can we do actually better well if bubble sort then is in big of of a squared sorry sorry spoiler if selection sort is in the order of a squared could we maybe get lucky sometimes like with selection sort what would the best case scenario be well the best case would be like everyone. Is already sorted 0 through 7 and we just get lucky but does bubble sort a are does selection sort appreciate that does selection sort take into account whether the list is already sorted not necessarily because if you look at the pseudo code even there's no special conditional in here that says if it's already sorted exit early it's just going to blindly do this this many times and you can actually see pseudo code wise then squared. Notice that this line of pseudo code here is essentially telling me to do what do something a times from 0 to a minus 1 or equivalently if you prefer the real world from 1 to a that's a times total but what are you doing inside of this loop well every time you're inside of this loop you're looking for the smallest element looking for the smallest element and that might take you as many as a steps so another way to think about the running time of this algorithm selection sort is this loop is telling you to do something a times this line is telling you to do something a times. Do something in times as well and that's roughly a times nor a squared it's not precise but it's on the order of a squared unfortunately if you're just blindly doing that much work always even if you have any number of doors this is going to end up being in omega of a squared as well because even in the best case where all of the numbers are already sorted there is nothing about the algorithm called selection sort or even my implementation thereof that would have said wait a minute. And exit prematurely so selection sort is in big of of and omega of us a squared as we've designed it and by coincidence because those boundaries are the same you can also say that it's in theta of a squared no matter what you're gonna spend a squared steps or a squared comparisons but that second algorithm that i keep teasing called bubble sort and i deliberately use the word bubble in my description of what was happening because eli i think was our first volunteer who kind of bubbled his way up all the way. Way to the end of the list then number six did then five then four then three then two then one all of the numbers kind of bubbled their way up being the bigger values to the right so bubble sort just does something again and again by comparing adj agencies comparing comparing comparing and then it does it again and again and again so let's analyse bubble sort if for instance this was the original array that we tried sorting before same exact numbers i was doing things like flipping the seven and the two and then the seven and the five and then the seven and the four. That would only fix maximally that would only fix minimally one number i then had to repeat again and again and again so that one too felt like it was taking some time so here's one way of thinking about bubble sore bubble sort pseudo code could say this repeat the following end times and that's why i kept going through the list again and again for i from zero to end minus two now this is a little weird but we'll get back to this from i from zero to end minus two if the number at location i. And the number at location i plus one are out of order swap them and then just repeat repeat repeat but we've never seen a minus two and pseudo code before why is it a minus two and not the usual a minus one yeah exactly because we're taking a number and comparing it to the next one so you better not go all the way to the end and expect there to be a next one at the end of the list so if we use the. These same numbers here even though they're in a different order if this is location zero and this is location a minus one always if you think of i as being my left hand it's pointing from zero to 12 to three to four to five to six to seven if you get to the end you don't want to look at i plus one because that's pointing to no mans land over here and you can't go beyond the boundaries of your array but a minus two would be the second to last element as you know and that makes sure that my left hand and right hand stay within the boundaries of the array if left hand. Represents i and right hand represents i plus one so it's just to make sure we don't screw up and go too far past the boundary of the array but as implemented here this too does not take into account whether or not the array is already sorted and so and technically we can actually do this end minus one times because the last one you get for free it ends up being in place but even still let's do a quick analysis here if we've got indoors in total from zero on up to a minus one bubble sorts analysis looks a little bit like. Do the following a minus one times a minus one times well how did we get from that let me back up to the pseudo code if this is the pseudo code as i originally put it i then may propose verbally a refinement you don't need to repeat yourself a times again and again because again the last one bubbles up but by process of elimination it's in the right place so you can think of it as just a minus one times how many times can you compare i and i plus one well you're iterating from 0 to a times. Minus two and this is where the mathis going to get weird but that is a minus one steps also why because if you do it in the real world with starting at one this is saying from i from one to a minus one and then maybe it pops a little more obviously this inner loop is repeating a minus one time so outer loop says do the following a minus one times inner loop says do this now a minus one times mathematically then that's a minus one times a minus one now we've got a real foil method son squared minus a. Minus and plus one combined like terms gives us a squared minus two in plus one but now let's think like a computer scientist when a gets really large we definitely don't care about the plus one when a gets really large we probably don't even care about the minus two a it will make a mathematical difference but a drop in the bucket once a gets to be in the millions or billions so this would be on the order of what similarly on the order of a squared as well so algorithmically and actually will use a different term now. Asymptotically asymptotic notation is the fancy term to describe big of and omega and theta notation asymptotically bubble sort is quote unquote the same as selection sort in terms of its upper bound it's not 100 exactly the same if we get into the weeds of the match they're obviously different formulas but when a gets really large and you plot the pictures on the on a chart they're going to look almost the same because they're going to be fundamentally the same shape so in our cheat sheet here bubble sort. Now is in big of of a squared but let me propose that we make an improvement here's our pseudo code earlier when might it make sense to abort bubble sort early like when could you logically conclude that i do not need to make another pass again and again and remember what i did from left to right over our volunteers i was comparing comparing comparing comparing and maybe swapping people who were out of order so what could i. Do to short circuit this perfect if i compare through the whole list left to right and i make no swaps it stands to reason that they're already ordered otherwise i would have swapped them and therefore i would be crazy to do that again and again and again because if i didn't swap them the first time around why would i swap them the second time around if no ones moving so i can terminate the algorithm early so in pseudo code i could say something like this if no swaps quit. And i can do that inside of the inner loop so once i make a pass through the people and i say hmm did i make any swaps if no just quit because they're not going to move any further if they didn't just move already so bubble sort then might arguably be an omega of what in the best case how few steps could we get away with with bubble sort of it's not one but it is a why because i minimally need to go through the whole list to decide did i make any swaps and logically and this will come up a lot. In the in the analysis of algorithms any question like is this list sorted cannot possibly take only one step if you've got a elements why because then you're just guessing like if you don't at least take the time to look at every element how in the world can you conclude logically that they're sorted or not like you minimally have to meet us halfway and check every element so it's minimally in omega of a constant time wouldn't even give you time to look at the whole list if there's a elements so that's the intuition there so we. We can't say anything about theta notation for bubble sort because it's different upper and lower bounds but we seem to have done better asymptotically than selection sort in the worst case they're just as bad they're super slow but in the best case bubble sort with that tweak that conditional about swapping might actually be faster for us and you'd want google microsoft your phone to use that kind of algorithm let me go back to the sorting demonstration earlier let me re randomize the array small bars is small number big bars is big number. And let me click bubble sort this time and you'll see again the pink represents comparisons but now the comparisons are always adjacent from left to right so this is pretty much doing with more bars what i did with eight people here and you'll see that the biggest elements eli being the first one of the humans bubbled up all the way to the right followed by the next largest next largest next largest but here again you can visually see and with the number of words i'm using to kind of stall here you can hear that. This is kind of slow because you're doing a lot of comparisons again and again and again and you're making improvements so you're taking bites out of the problem but really only one bite at a time so i kind of feel this is going to be like holding in a sneeze if we don't finish this so i feel like we should give you emotional closure with getting this to finish any questions in the meantime because there's going to be no surprise it's going to be sorted this is bubble sort no all right we're almost there. It's going faster because the list is effectively getting shorter and so that then was bubble sort but both of these i claim now are actually pretty inefficient they're pretty slow and my god that was only eight humans on the stage that was only like what 40 or 50 bars on the screen what if we start talking about hundreds or thousands or millions of inputs like those algorithms are probably going to take crazy long because a squared gets really big so can we do better than a squared. Well we can but let me propose that we introduce a new problem solving technique that we've actually been using already just not by name in programming and in mathematics there's this idea of recursion and recursion is a description for a function that calls itself a function that calls itself is recursive so what do we mean by this well we've actually seen this already here's the same pseudo code for binary search earlier. I am playing to went either left or right or left or right having each time so that was the division and conquering so this is the same pseudo code but notice that in my pseudo code earlier i literally use the keyword search inside of my definition of search so this is sort of one of those like circular definitions like if this is a search algorithm how am i getting away with using the word search in the definition of search you know it's kind of when you get reprimanded for using a word to define a vocabulary word this is kind of like that. Because this algorithm is calling itself this search function is calling itself now normally if you were to have a function call itself call itself call itself call itself it would just do that infinitely and presumably it would go on forever or the program or computer would probably crash because out of memory or something like that more on that next week but there's a key detail of key characteristic about this algorithm that makes sure that doing the same thing again and again is not crazy it's actually going to lead us to a solution even though. I'm using search here or search here what's happening to the size of the problem for each of these lines what's happening yeah it's being cut in half so even though i'm doing the exact same thing algorithmically again and again i'm doing it on a smaller smaller smaller input fewer fewer fewer doors fewer fewer fewer people and so even though i'm doing it again and again so long as i have this so called base case as we'll call it that just makes sure if there's no doors you're done i can. And break out of what would otherwise be an infinite loop of sorts all right so those two lines we've already kind of seen and actually we saw this in week zero so this is the pseudo code for the phone book example from week zero and you might recall that we had these lines of code here and this is very procedural or iterative where i literally told you go back to line three and we did that today when we took attendance so to speak with that third algorithm you went back to step two again and again that's a very iterative loop based approach but you know what i could be a little more clever here. Two in week zero we just didn't want to get too far ahead of ourselves let me actually change these highlighted lines to be more succinctly search left half of book search right half of book i can now tighten the code up so it's kind of a shorter algorithm but it's the exact same idea but on week zero i very methodically told you what i want you to do next but here i'm sort of recognizing that wait a minute i just spent the past six lines telling you how to search so go do more of that you have all of the logic you need so this too is. Recursive in the sense that if this is a search algorithm the search algorithm is using a search algorithm inside of it but here too the phone book was getting divided and divided and divided in half again and again so recursion doesn't just describe mathematical formulas it doesn't just describe pseudo code or code even physical structures so we deliberately brought back these bricks here today which are reminiscent of course for mario and super mario brothers that pyramid especially if we get rid of the distractions of the ground and the mountains and so forth is itself recursive. As a structure now why is that well here you can kind of play verbal games if this is a pyramid of height four and ask the question well what is that what is a pyramid of height four i could kind of be difficult and say well it's just a pyramid of height three plus one other row all right well what's a pyramid of height three you could be difficult and say well it's just a pyramid of height two plus one more row what's a pyramid of height two well it's this plus one more row i might have skipped a step there what's a pyramid of height two. Well it's a pyramid of height one plus one more row what's a pyramid of height one well it's nothing plus one more row or at this point you can just say it's a single brick you can have a base case that just says like the buck stops here stop asking me these questions i can special case or hard code my answer to the very tiniest of problems so even those bricks then are sort of recur the pyramid is recursively defined and we can actually implement this even in code if we want in a couple of different ways to make this clear so let me go back over to the a code here. Propose that we do one old school iterative example with this code iteration dot a and iteration just means to loop again and again and iteration is a pass through the code and let me go ahead and whip this up as follows let's include the csc a library so we have our get int function let's include standard i of so that we have print of let's go ahead and create main with no command line arguments today let's go ahead and create a variable of type int. Set equal to the return value of get and asking the user for the height of the pyramid and then let me assume for the sake of discussion that there is a function now that will draw a pyramid of that height all right now let's actually implement that function as a helper function so to speak so if i have a function called draw it's going to clearly take an integer and i'll call it maybe a as input and it doesn't need to return anything so i'm going to say that this is a void function doesn't return a value it just has a side effect of printing bricks on the screen how can i go about doing that. A pyramid of height a well i'm going to do this one which looks like this one at a time then two then three then four and this is a little easier for instance than problem set one which had the pyramid flipped around the other way so this ones a little easier to do deliberately so if i go back to my code i could say something like this 4 int i gets 0 i is less than let's say a which is the height i plus plus that's going to essentially iterate over every row of the pyramid top to bottom. This might feel similar reminiscent to problems at one then in my inner loop i'm going to do four int a gets zero a is less than i plus one a plus plus and we'll see why this works in a moment and then let's go ahead and print out a single hash no new line but at the very bottom of this row let's print out just a new line to move the cursor down a line now i'm not done yet let me hide my terminal for a second i need the prototype so i'm going to copy this. Paste it up here with a semicolon and i think now the code is correct now why is this correct because on my outer loop i'm iterating a times starting at zero my inner loop realize i want to have at least one hash then two then three then four so i can't start my number of hashes at zero and that's why i'm doing a all the way up to i plus 1 so that when i is zero i'm actually still printing one hash and then two hashes. Otherwise i would start with zero which is not my goal let me go in and do make iteration to compile this dot slash iteration and let me go ahead and make my terminal bigger enter the height will be for instance four and indeed it's not quite to scale because these are a little more vertical than they are horizontal but it essentially looks like that pyramid and i can do this even larger let's do this again after clearing my screen let's do like 10 of these and it gets bigger let's do like 50 of these and it gets even bigger it doesn't even fit on the screen but it works. That's an iterative approach 100 correct and similar to what you might have done already for something like week zero or week one but it turns out if we leverage recursion we can be a little more clever in fact let me go ahead and do this let me minimize my terminal window let me go back into my code here and let me propose to implement the exact same program recursively instead and let me go ahead and do this i'm going to leave main. Let's see exactly as is and i'm going to go ahead and change my draw function to work as follows let me delete all of these loops because loops are sort of an indication of using iteration and i'm instead going to do this what is a pyramid of height for i said it's a pyramid of height three plus one more row so let's take that literally if a pyramid of height a needs to be drawn let's first draw a pyramid of a minus 1. And then how do i go about drawing one more row well this i can use a bit of iteration but i don't need a double doubly nested loop anymore i can set i equal to 0 i less than a i plus plus and this block of code is simply going to print one simple row of hashes again and again followed by a new line just to move the cursor down so notice this line here and i'll add some comments print pyramid line. Of height a minus one print one more row so i'm kind of taking a bite out of the problem by printing one row but i'm deferring to weirdly myself to print the rest of the pyramid now i'm going to go ahead and try compiling this make us of and this is no longer iteration so i'm actually going to do this code recursion dot a i'm going to paste that same code into this new version just so we have a different file without breaking the old one and now i'm going to do make. All right interesting so clang is yelling at me with this error all paths through this function will call itself so clang is actually smart enough to notice in my code that no matter what the draw function is going to call the draw function and the draw function is going to call the draw function the draw function is going to call the draw function now to be fair and the input to draw is getting smaller and smaller but what's going to happen eventually to the input of draw as i've written this code right now yeah in back. Exactly remember that integers are signed by default they can be both positive or zero or negative and so here if i just keep blindly subtracting 1 it's going to do that seemingly forever until i technically underflow but that's going to be like 2 billion rows of pyramids later so i think what i actually need to do is something like this i need to ask the question if a equals 0 or heck just to be super safe let's say if a is less than or less than. Equal to zero just to make sure it never goes negative let's just go ahead and return without doing anything so i'm going to comment this is like if nothing to draw well then don't blindly call draw again so this is that so called base case this is analogous to saying like if john harvard not in phone book or if no lockers or doors left then just exit or return in this case so now i'll never call draw a negative number of times or zero number of times i will only do it so long as a is. Positive so now if i make my terminal bigger make recursion again does compile fine dot slash recursion let's do the same input for and i get the exact same number of bricks let's go ahead and do it again with maybe 10 that seems to work too let's do it again with 50 that seems to work too and i can go a little crazy i can do like 5000 this is still gonna work it's just not gonna fit on my screen but it is doing a valiant attempt to print all of those out now it turns out that. Get us in trouble if we start poking around in the maybe not 5000 but 500 000 or 5 million or beyond but for now we'll just assume that this is just a slow process at that but if we go back to the goal which was to print this thing here this too is a recursive structure that we're just now translating the ideas of recursive code to and actually if you've never discovered this we would be remiss in not doing this for you if i go into a browser here and suppose that i'm not using any a fancy. I'm just going to google com and i search for a recursion because i'm curious to see what it means google for years has had this little easter egg for computer scientists it's not a typo get it a a kind of funny yeah of like see recursion so if you click recursion of now we're in night mode for some reason but of like so it just does this endlessly of so programmers with too much free time. Or too much control over googles own servers to do that so it turns out yes if you search for recursion on google this is a longstanding easter egg in this case but the point of introducing recursion is that one it's actually going to be a very powerful problem solving technique because honestly it one we've seen in pseudo code already kind of tightens up the amount of code or the amount of lines that you need to write to convey an algorithm and two it will actually allow us to solve problems in a fundamentally different way by using computers memory in an interesting way and so toward that end we wanted to introduce one. Final sort today which we won't use humans to demonstrate but just numbers instead namely something called merge sort and merge sort is an algorithm for sorting a numbers that i claim is going to be better than selection sort and bubble sort it's got to be better because that a squared was killing us we want to get something lower than a squared so merge sorts pseudo code essentially looks like this and this is it merge sort says if you've got a numbers or an array of numbers sort the left half of them. Sort the right half of them and then merge the sorted halves and we'll see what this means in just a moment but if there's only one number just quit so this is my base case because this is recursive because if this is a sorting algorithm called merge sort i'm kind of cheating by using the verb sort in the sorting algorithm but that just makes it recursive it doesn't make it wrong so what do i mean by merging just to make this clear here among these numbers are two lists of size four and i'm going to scotch them over to the left and the right just to make clear that on the left. Is one half that is sorted 1 3 4 6 from smallest to largest on the right is a second half that's also sorted 0 2 5 7 so for the sake of discussion suppose that i'm part way through this algorithm called merge sort what and i've sorted the left half already clearly i've sorted the right half already clearly now i need to merge the sorted halves what do we mean by that well that means to essentially us conceptually point your left hand at the first at the left half. Point your right hand at the right half and then decide which of these numbers should come first in order to merge or kind of stitch these two lists together in sorted order well which is smaller obviously zero so that last step merge sorted halves would have me take this number and put it in an extra empty array up here now i move my right hand to the next number in the right half and i compare the one and the two obviously one comes next so i put this now up here now i compare the three and the two obviously the two comes next. And so i put this up here three and five obviously three four and five obviously four six and five obviously five and six and seven obviously six and i didn't leave quite enough room for seven perhaps and lastly seven so that's all we mean by merging two lists together if they're already sorted you just kind of stitch them together by plucking from one or the other the next number that you actually want. And that's it and even though i picked up partway through this algorithm those three steps alone would seem to work so long as you can sort the left half and sort the right half you can surely then merge the sorted halves now i'll go ahead and do this digitally rather than use the physical numbers because clearly it's a little involved moving them up and down but this rack here this shelving essentially represents one array with maybe a second array here and heck if i really want it a third and a fourth array it turns out that with selection sort and bubble sort we've really been tying our hands because i only. Allowed myself a constant amount of memory just one variable in my head for instance with selection sort that let me keep track of who was the smallest element and when we did bubble sort the only number i kept in mind was i like i and i plus one i didn't allow myself any additional memory but it turns out in programming and in is you can trade off one resource for another so if you want to spend less time solving a problem you've got to throw space at it you've got to spend more space spend more money in order to give yourself more space to reduce your time. Conversely if you're fine with things being slow in terms of time then you can get away with very little space so it's kind of like this balance whereby you have to decide which is more important to you which is more expensive for you or the like so let's go ahead then and consider exactly this algorithm as follows so suppose that these are the numbers in question so here is our array it's clearly unsorted i'd like to sort this i could use selection sort. But selection sort was not great because it's big of of a squared and it's omega of a squared so sort of damned if you do damned if you don't bubble sort was a little better it was still big of of a squared but sometimes we could get lucky and shave some time off so it was omega of only a let's see if merge sort is fundamentally better and let's do so by trying to reduce the number of comparisons no more looping back and forth and back and forth and back and forth endlessly so here's how we can draw inspiration from the idea of recursion and divide and conquer as per week zero. Let's first think of these numbers as indeed in an array contiguous lee from left to right let's then go ahead and sort the left half because again the pseudo code that you have to remember throughout this whole algorithm has just real three real steps sort the left half sort the right half merge the sorted halves and then this is sort of a one off thing but it's important but this is the juicy part sort left half sort right half merge the sorted halves so if we go back to this array on the top shelf here's the original array let's go ahead and sort the left half and i'm going to do. So by sort of stealing some more memory so i can sort of work on a second shelf with just these numbers so 6341 is now an array of size four essentially how do i sort an array of size four well i've got an algorithm for that selection sort but we decided that's slow bubble sort that slow wait a minute i'm in the middle of defining merge sort let's recursively use the same algorithm by just sorting the left half of the left half so if you've got an array of size four it's only three steps to solve it sort left half sort right half merge. So let's do that let's sort the left half of wait a minute how do you sort an array of size two i've got an algorithm for that sort the left half sort the right half merge the two halves all right let's sort the left half what now so six is a list of size one what was that special base case then so if it's quit or just return like i'm already done so this list of size one is sort of weirdly already sorted so i'm making progress meanwhile what's the next step after sorting. This left half sort the right half done this is already sorted but here's the magic what's the third step for these numbers merge them so this is like the left hand right hand thing which one comes first obviously three and then six and now we are making progress because now the list of size two is sorted so what have i just done i've just finished sorting the left half of the left half so after i've sorted the left half what comes next if you rewind in time. Sort the right half of that left half so now i take the right half and how do i sort this right half of size two well sort its left half done sort its right half done now merge them together and obviously the one comes first then the four now where are we we're at the point in the story where we have a left left half sorted and a right left half sorted so what comes next now narrative merge the two together. So left hand right hand so 1 3 4 6 and where are we now in the story we're sort of at the beginning because i've now sorted the left half and you recall the demo i did physically this is how i had the left half was already sorted on the second shelf but now that i've sorted the left half of the original array what's the original second step sort the right half so it's the same idea so i'm borrowing some extra memory here and now i've got an array of size 4 how do i sort an array. Array of size four sort the left half all right how do i sort an array of size to sort the left half done sort the right half done now what merge the two together and of course it's two and five now what do i do i've sorted the left half of the right half so now i sort the right half of the right half how do i sort a list of size two well sort the left half done sort the right half done merge them together zero and seven where am i in the story i've sorted the left half. Half and the right half of the original right half so i merged these two together zero and then two and then five and then seven where are we we're at exactly the point in the story where we had the numbers originally on the second shelf we had a list that's sorted on the left a list that's sorted on the right and what i demoed physically was so emerging those two together so what happens now 0 1 2 3 4 5 6 7. And it seems kind of magical and kind of weird in that i kind of cheated and when i had these leaves these leaf nodes so to speak these singletons i was like sorted i wasn't really doing anything but it's that merging that seems to really be doing the magic of sorting things for us so that felt like a mouthful and recursion in general is the kind of thing that will like bend your brain a little bit and if that went over your head like that's fine it takes time and time and time and practice but what there was not a lot of with this algorithm was again and again. And again and again and again i was kind of only doing things once and then once i fixed a number i moved on to the next and that's sort of the essence of this algorithm here if it helps you to see it in another visual way let me go back to our previous visualization here let me re randomize the array and click merge sort and this time notice that merge sort is using more space technically i was using one two three shelves but you can actually be slightly more intelligent about it and actually just go back and forth and back and forth between two shelves. Just to save a little space so you're still using twice as much space but you don't need four times as much space as the diagrams or as the shelves might imply so here is merge sort and you'll notice that we're sort of working in half sometimes big have sometimes smaller halves but you can see as the two halves are merged things seem to happen very quickly and so notice that this is the same number of bars as before but that was way faster right i don't need to stall nearly as much as i have in the past so so why is that. Well if we go back to the diagram in question here's the list that's our here's the array that's already sorted and if we consider now exactly how much work is done i'll stipulate already it's not in squared and squared was slow and merge sort is actually much better than that let's see how much better it is so here is the original list 63 four 15270 and here are all of the remnants of that algorithm all of the states that we were in at some point sort of leaving a whole bunch of bread crumbs how many pieces of work. Did i do well like 1234 5678 9 10 11 12 13 14 15 16 17 18 19 21 22 23 24 so i moved things around like 24 times it seems and how do i actually reason about that well these are the numbers this is like my temporary workspace here and 24 is the literal number but let's see if we can't do things a little more generically log base to event recall is what refers to anything that we're doing in half dividing dividing. Dividing dividing and that's kind of what i was doing here i took a list of size eight divided into two of size four then four of size two then eight of size one well how many times can you do this if you start with eight numbers well that's log base two of eight and if we do some fancy match that's just log base two of two to the third and remember the base and the number here can cancel out so that's actually three so log base two of eight is three which means that's how many times you can divide a problem of size eight in half in half in half. But every time we did that per this chart i had to take the numbers and merge them together merge them together merge them together and so on every row of this postmortem of the algorithm there are a steps a steps a steps so laterally there's a steps because i had to merge all of those things back together but what is the height of these yellow remnants well it's 3 which is log base 2 of 8 which is 3 so this is technically 3 times 8. Go 24 steps but more generally this is log a height and a width so to speak so the total running time i claim is actually a log a which it's of if that doesn't quite gel immediately in your mind especially if you're rusty on algorithms but and we can throw away the base because that's just a constant factor and with a wave of our hand when we talk about big of notation merge sort i claim is in big of of a log a that is a times log a. Unfortunately it is also in omega of a log a which means that frankly bubble sort might sometimes outperform it at least when the inputs are already sorted or certainly very relatively small but that's probably of because in general data that we're sorting probably isn't very sorted and honestly we could even hack merge sort to just do one pass to check initially is the whole thing sorted and then maybe terminate early so we can maybe massage the algorithm a little better to be a little smarter but fundamentally. Is in theta of a log a is how you would say it it's on the order of a times log a steps now in terms of that chart it's strictly higher than linear but it's strictly lower than quadratic a and a squared respectively so it clearly seems to be faster so it's not as good as linear search and it's definitely not as good as binary search but it's way better than selection sort or bubble sort actually were so with that said we thought we'd get a little bit of a break. Conclude by showing you a final film that's just about a minute long that compares these actual algorithms and shows them as follows you'll see on the top the middle and the bottom three different algorithms on the top you will see selection sort on the bottom you will see bubble sort and in the middle you will see and hear an appreciation of what a log a is a a a merge sort today so if we could dim the lights dramatically this is a log a visa. The in squared. So. All right that's it for cs50 we'll see you next time. You