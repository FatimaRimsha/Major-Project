Selection sort is an algorithm that as you might expect sorts a set of elements an algorithm recall is a step by step set of instructions for completing a task in selection sort the basic idea is this find the smallest unsorted element and add it to the end of the sorted list effectively what this does is build a sorted list one element at a time breaking it down into pseudo code we could state this algorithm as a set of elements. Repeat this until no unsorted elements remain search through the unsorted data to find the smallest value then swap the smallest value with the first element of the unsorted part it may help to visualize this so let's take a look at this so this i contend is an unsorted array and i've indicated it by indicating that all of the elements are coloured red they are not yet sorted this is the entire unsorted part of the array so let's go through the steps of selection source. To sort this array so again we're going to repeat until no unsorted elements remain we're going to search through the data to find the smallest value and then swap that value with the first element of the unsorted part right now again the entire array is the unsorted part all of the red elements are unsorted so we search through and we find the smallest value we start at the beginning we go to the end we find that the smallest value is 1 so that's part 1 and then part 2 swap that value with the first element of the unsorted part or the first element. In this case that would be 5 so we swap 1 and 5 when we do this we can visually see that we've moved the smallest valued element of the array to the very beginning effectively sorting that element and so we can indeed confirm and state that 1 is sorted and so we'll indicate the sorted portion of our array by colouring it blue now we just repeat the process again we search through the unsorted part of the array to find the smallest element in this case it's 2 we swap that with the smallest element. With the first element of the unsorted part in this case 2 also happens to be the first element of the unsorted part so we swap 2 with itself which really just leads to where it is and it's sorted continuing on we search through to find the smallest element it's 3 we swap with the first element which is 5 and now 3 is sorted we search through again we find the smallest element is 4 we swap it with the first element of the unsorted part and now 4 is sorted we find that 5 is the smallest element. Swap it with the first element of the unsorted part and now five is sorted and then lastly our unsorted part consists of just a single element so we search through it we find that six is the smallest and in fact only element and then we can state that it is sorted and now we've switched our array from being completely unsorted in red to completely sorted in blue using selection sort so what's the worst case scenario here well in the absolute worst case we have to look over all of the elements of the array to find. The smallest unsorted element and we have to repeat this process a times once for each element of the array because we only in this algorithm sort one element at a time what's the best case scenario well it's exactly the same right we actually have to still step through every single element of the array in order to confirm that it is in fact the smallest element so the worst case run time we have to repeat a process a times once for each of a elements. We have to do the same so thinking back to our computational complexity toolbox what do you think is the worst case run time for selection sort and what do you think is the best case run time for selection sort did you guess big of of a squared and big omega of a squared you'd be right those are in fact the worst case and best case run times for selection sort i'm doug lloyd this is cs50. You