Of well hello one and all and welcome to cs50's third section this one for week three my name is carter bank the courses preceptor and the goal of these sections is to help you bridge the gap between the lecture you perhaps just watched and the problem set you'll tackle this week or perhaps throughout the rest of some other period of time and be working on that problem set now today we actually are going to talk about a few different topics among them are these here so talk about how we can learn. About algorithms discuss what they do and what they are but also how we can compare algorithms like what makes one algorithm better than some other algorithm we'll talk about that today we'll also talk about this idea of a struck or a structure allowing us to make our very own data types and we'll also towards the end talk about this idea of recursion or trying to define something by defining it within itself and that all hopefully make a little more sense towards the intersection but it is a powerful tool you can use to solve problems. Problems in computer science and a worthwhile tool to have in your toolkit as a computer scientist so let's begin by jumping into our very first topic which is how we can compare algorithms and in lecture we had two algorithms we were going to think about or two types of algorithms if you will one of them is algorithms we can use for searching how we can find certain data from a data set and then another type of algorithm for sorting how do we order data to make things perhaps more efficient to search later on. And we also talked a bit briefly about these notations we could use to compare algorithms you might recall big of notation and big omega notation so we'll talk more about those in section today now let's go back as a bit of a review and think first through some searching algorithms so here i have a list of people you can see on my screen and currently what do you notice people here are not quite sorted by name we have matthew first then samoa then alyssa. So this is quite in alphabetical order and if i could ask you all what is the algorithm we want you to search in this case an array of people if we know the list isn't sorted what kind of algorithm could we use in this case so i'm seeing some people say linear search and linear search to be clear is when we start at maybe one side of this list and just look at the very first person then the next person then the next person and so on. So let's pretend here we're trying to find this person alyssa among these seven people so if we are a person i could very clearly spot alyssa like alyssa seems to be right here right that's not too hard for me i could do that in one step but a computer has to look at only one piece of information at a time so it looks a bit more like this you can imagine these people being on a stage and us dimming the lights and allowing us to only see one person at a time so if we're a computer we might look first and see matthew. And does matthew alyssa no so we're going to look at the next person right so turn our spotlight to the next person we'll see samoa and we're not quite there yet we'll take the next person now we'll see still alyssa so now we have alyssa on our third try going through person by person left to right this is an example then of linear search so let's imagine that we go back and turn on all the lights and we have people in this case rearranged. So notice how their names are in alphabetical order we have alyssa then cecilia then douglas then lucas what kind of algorithm could we use now to search for alyssa we saw this in lecture two some people say this idea of binary search and we actually saw a binary search in our very first lecture when david took a phone book and opened it to the middle and asked if we went too far or not far enough tore off. Half of it and they kept going and going and going so a similar idea applies to binary search in this case with people too so let's again dim the lights and let's only look at one person and if we're using binary search we know it's perhaps most efficient to look in the middle and ask ourselves have we gone too far or not far enough in our list so let's look in the middle and here we get lucas have we gone too far in our list or not far enough. Seems like we've gone a little too far if alyssa name begins with a lucas is after alyssa in the alphabet so let's say of let's not worry about lucas or people after lucas let's focus on the first half of people here and look in the middle of that so it turns out the middle of our first half here is going to be cecilia and again have we gone too far or not far enough seems we've gone a little bit too far still. The same thing we'll take that half of the problem and tear it away and now we'll focus just on that very first half and it turns out the very first person in that first half here is going to be alyssa themselves so we have two algorithms here one called linear search and one called binary search but it's also worth thinking about how we can compare them so let me ask you here how many steps did each algorithm take if you can think back just in terms of a plain old number of steps how many. To. Say based on what you saw in lecture if i were arguing with you that linear search is the exact same as binary search what would you say so i'm seeing some people say it depends on the problem size which does make sense depends on the input that we get so perhaps maybe we just got a little unlucky here and both binary search and linear search took three steps but that might not be the case in all inputs. If it depends on the size of our data set so in this case if we had a very very big data set we heard or saw in lecture that binary search might be a little bit better for that big data set so let's think instead as a computer scientist would and think not just in terms of this one particular input but in terms of input in general in the general case how well do each of these algorithms perform so a better question to ask here is this one which is. What's the greatest number of steps these algorithms will ever take and let's focus actually just here on our seven people let's say how long would linear search take if we took the greatest number of steps here seems like seven right so seven steps we have to go through all of the different people to find out have we found the person we're looking for or not so it seems like seven what about binary search though what's the greatest number of steps. Number of steps it would ever take if we had seven people i'm seeing a over 2 or dividing it in half and you're almost there and in fact it is a logarithm so a logarithm allows us to take something and divide it in half divide it in half again and divide it in half again so it's more appropriate here to say that linear search takes about seven steps and binary search for this particular input of seven people takes log base 2 of 7 which basically means however many times. Times we can divide 7 by 2 which turns out to be something like let's see maybe like 3 or so steps so in the worst case if you will linear search takes 7 steps in the worst case binary search takes far fewer and therefore might be a better algorithm so what questions do we have so far on this idea of comparing these algorithms using the worst possible case. Any questions i'm seeing a question here about big of notation which is where does that come in so that's actually going to be our next step here so we often don't think about problems in terms of the exact number of elements we're searching we often might think about in an even more general case just some number of people like a if we had 7 or 8 or 10 or 1 000 who cares. And so now we could say well linear search in the worst case the greatest number of steps we'll ever take is going to ben steps one for each person or we assume we have a people now binary search would do the same thing it would say let's actually not go through all a of them let's divide things in half and in half and in half again so the most steps we'd ever take would be log base 2 of a where again a is just the general number of people we have. But we have overall it could be 10 100 1 000 and so on but now computer scientists because we often work with data sets that are so large and so big on the order of millions or billions of pieces of data we don't often care about things as robust as of is it log base 2 event or log base 3 we care about even more general case and that's where this idea of big of notation comes in so we might say that linear search operates on the order. Of a steps and in the same way binary search operates on the order of log of a steps so thinking here not even about the general case of like of is it 7 or 10 people but just like what are we actually doing here how does the problem scale as we add new people so big of notation then is used often for this question of what is the greatest number of steps algorithm will ever take if you're more technical you could think of it as the upper. So questions then on the transition between talking in terms of individual steps and talking now in these general hand wavy cases questions are a faster way than binary search it's a good question so if you get really into this you can find other kinds of algorithms to search data. Be cases that could be a little faster than binary search i don't know any off my head but certainly there are researchers who are working on that kind of thing to figure out how to write a faster algorithm than for instance something like binary search of so let's keep going and let's think about a different kind of scenario so here we're talking about the worst case the greatest number of steps our algorithm will ever take but there are some other case too so let's consider this one well we're still trying to find alyssa. And we're using linear search so let's say it just so happened to be that alyssa is the very first person we find how many steps did that take well just one right and now let's think too about a binary search let's say we have this input of people they're kind of shuffled a little bit we have aaron amelia alex alyssa cecilia lucas and rama and we're doing binary search we're still looking for alyssa and if we were to do binary search on this data set where we're going. What did we first look well the middle so it took us only one step to find alyssa here so there's another question we could ask then which is this well first how many steps did the algorithm take did each one take well we talked about how linear search took one and sort of binary search but in general we could also ask this question what's the fewest number of steps the algorithm could ever take so with the of notation we talked about what's the greatest number but now we're asking what's the fewest. Number the algorithm could ever take and in this case you could kind of simplify things and say what happens if we get lucky well it turns out that in linear search the best fewest numbers that we could take is just one our purse at the very front of our list and in binary search it's similarly just one our purse at the middle of our list so in this case it's still the same linear search and binary search the best case they only take one step. And so in general as we just talked about computer scientists don't tend to think about one particular input they think about general inputs what happens in just the overall best case and we could say even if we had 10 people 100 people 1 000 people the best case scenario each of these algorithms would take one and only one steps and that's where this idea of omega notation comes in so omega notation says what given any kind of input would be the fewest number of steps. We would ever take and now here too is this idea that omega notation doesn't even quite care if it takes 2 or 3 or 10 steps in the best case if it takes some fixed number of steps it only is going to be written as omega of 1 and there other notation we'll consider too which i'll show you in just a bit but consider for now that even if it took a fixed number of steps 10. 100 1 all this will be written as basically omega of 1 indicating it takes some certain number of fixed steps in the best possible case so questions then on these algorithms i see a question here are linear search and binary search the only algorithms that we can search data with certainly not there are many researchers who are working on other algorithms we can use to search data and you might find some that are suited for particular use. Case and from lecture you might have recalled david saying that there's often a trade off between let's say between space and time you could perhaps have an algorithm that uses a lot of space but could perhaps be a little bit faster in searching something because it uses so much space good questions a question about can we define an algorithm so it's a good question here like what even is an algorithm to begin with we often say an algorithm is simply a set. Of steps to accomplish some task and those steps have to be very clearly defined like in linear search we look at the first person then the next person then the next person until we get to the very end good questions here any others so far of so here's a question for you all then suppose that you are creating a new algorithm and you want to assess its run time. So what exactly does it run you find out that the fewest steps this algorithm will ever take is two and only two and now the question is what is the big omega notation for this algorithm keeping in mind what we've just discussed suppose in the best case this algorithm takes two steps what would be the omega notation for this algorithm i'm seeing a few answers here which is actually what i had hoped for. I'm seeing some saying it would be omega of 1 and some saying it would be omega of 2 so if we go back here maybe we wouldn't have omega parentheses 1 but we instead have omega parentheses 2 and i think it's a good intuition like if you know that the best case will take you two steps i mean it kind of just makes sense to write omega of 2 but it turns out that computer scientists by convention like to think of things as being on the order of some number. Of steps and whether it takes two three four if it takes some fixed number of steps we'll say it operates in omega of 1 to symbolize that it just takes some finite number of steps in the best case so not omega of 2 but instead omega of 1 by convention in this case so some other notations you might see as you often learn more about algorithms are these here so on the furthest left hand side you'll see the big of notation. The worst case if you will so you'll have algorithms that in the worst case take some fixed number of steps they'll be in big of of 1 there are other algorithms like we just saw binary search that operate in big of of log a they keep dividing problems in half and half and half again there are still others that operate in big of of a that means they have to take a look at every individual element they might be searching for and then there are some that operate in big of of a. Go of a squared where for every element they have to take that number of element steps before they can move on to the next one and the next one and the next one and in general here we don't really care if it's big of of a squared plus another 10 steps at the end in general we care about the biggest term a squared a log nor 1 and same thing for omega notation here but now thinking about not the worst case but the best case or the fewest number of steps the algorithm. Algorithm could ever take and a question here is well let's say the algorithm takes maybe 100 steps in the worst case what would that be well it kind of depends now if the algorithm takes 100 steps in the worst case we have to ask ourselves not so much how many steps the algorithm took in that case but instead how the steps scale so if the algorithm will always take 100 steps and only 100 steps in the worst case. The worst case that would actually be big of of 1 because it's some fixed number of steps if though i were to add one more element and you then need to do 101 steps or if i added two elements and i had to do 102 steps that would be an example in the algorithm big of of a because for every element i add i could do one more step questions two on these notations. Question about encountering algorithms in other languages like python for instance as you'll see later on in cs50 so certainly there's this idea that we can take most any algorithm and translate it into really any other language so for the first few weeks of cs50 you'll be using a later on you'll use python you can take most any of these algorithms and put them into any language you'd like good questions here. So let's try actually putting some of this into practice and so the very first problem this week is one called sort in which you're given some various sorting algorithms so we've talked here about searching algorithms but now let's try and think about sorting algorithms so in lecture we saw three different sorting algorithms and here they are along with their big of and big omega notations so notice here that we have merge sort which we saw was a merge sort. So this is among the fastest of our sorts you can see that merge sort has a big of notation of big of of a times log a and the same thing for its omega notation big omega of a times log a now this is faster than selection sort and bubble sort so we'll see selection sort here it was big of of a squared and bubble sort is also big of of a squared. So actually bubble sort is also omega of a squared but for bubble sort omega of a and so actually i said earlier that merge sort is faster than these two but can you think of a scenario where you might actually want to use bubble sort as opposed to merge sort what scenario we might want to use bubble sort instead of merge sort there is a case where bubble sort is faster. Like it's faster if we are in one of our cases that seems like one of our best cases and if we're talking about sorting algorithms well if we know our data is close to being sorted and we just want to check is it sorted or is it not bubble sort could be a good way to do that faster in this case than merge sort and we know this looking at the notation here we see omega of a for bubble sort and omega of a times log a so that is for every step we do. We have to add in another log a steps in merge sort but for bubble sort we don't have to actually do that in this case so i find it helpful to see these things in a bit of a chart and the sorting problem asks you to figure out the identities of three mystery sorts so here you're given sort 1 sort 2 and sort 3 and your job is to time them and see which. Algorithm each sort might be using and one approach here is to think about like of and of notation the best and the worst cases give them those inputs and see how long it takes them to run and then compare them compare those run times and see which one you think might best characterize the algorithm you are just testing so here our goal will be to fill in a chart that looks a bit like this where we have a reversed 50 000 numbers. Possible case our numbers are in the exact wrong order we'll go through and time each of our algorithms and see perhaps which one runs the fastest which ones run the slowest and we'll do the same thing but now given a sorted list our numbers are in the best possible condition they're already sorted for us and we'll ask that same question how long in general does each one seem to take and so by timing our sorts we'll go to figure out do they run. Or they seem to run more equivalently too of a squared or of of a log nor something in between so in this case let's actually go back to visual studio code and i will restart mine here once you connect to yours you'll be able to actually download some of the distribution code for the sort problem and you'll be given in this case three different sorting programs along with the inputs i just mentioned. So i'll wait for mine to start here but our goal will be to look at each of those three sorting algorithms time them and make note of let's say which one might be most equivalent to the three algorithms we just discussed so far so it seems my code space is ready to go here let me hide a few things to get out of your way and let me show you where i have my files so if you download them you should be able to see them in your very own folder called. So now let me show you what's inside answers text i'll say code answers text and now i'll see what i'm supposed to do. To identify which algorithm each of these sorts uses so sort1 for instance could use merge sort or it could use let's say bubble sort could be any of these things my goal is to type it in and figure out which algorithm this sort is using and then down below type in why i think that's the case so let's try timing these given the best and worst case inputs and seeing how well each one does. So i'll go to my terminal here and if you read through the problem specification it'll tell you that you can time these sorts using this you can say time and then followed by the command to execute the sort so in this case i want to run sort1 i can type sort1 and give it either the best or the worst case scenario maybe i'll give it the worst case to begin with i'll say let's give sort1 a reversed list of 50. 1000 50 000 numbers and just time it and see how well it does so i'll hit enter and i'll see it's thinking maybe it's sorting this list for me and now down below i can see how long it took to take all 50 000 of these numbers and put them in sorted order so it seems like sort 1 took about 4 64 seconds and you're given three different times here real user and system time. In general you'll care about just the real time how long did it take based on a stopwatch in this case so i can go back to my answer text and i could say well i'll just make notes sort1 seemed to take takes 4 64 seconds in worst case or maybe let's be more particular to sort reversed list like this now i might also care about the first case. Care about how this algorithm performs in the best case so i'll go back to my terminal and i'll then say let's time it again but use dot slash sort one and now let's choose the sorted list sorted 50 000 dot text and it enter and see how well it does now that was a lot faster that only took 0 3 seconds about so i'll go back to my answers page and i'll write that down i'll say it takes 0 3 seconds. 3 seconds to sort a sorted list already and i keep going here and if you're watching this not live i encourage you to pause the video and go through and time the other sorts if you are here live we'll go through and time these ourselves and put them all together in our answer text so let's keep going i'll go ahead and say i will run sort2 now but i want to time it time sort2 let me give it the sorted 50 000 actually the reversed. The reversed 50 000 numbers see how long it takes that was pretty quick so i'll say it takes 0 27 seconds to sort reversed list let's try again doing not reversed but now sorted that was still pretty quick so it takes 0 45 seconds to sort a sorted list and now i'll try sort 3. Now let me move this down to here let's try sort 3 i'll say give sort 3 the reversed 50 000 see how long that takes a little slower i'll say it takes 2 25 seconds to sort reversed list and now i'll try sort 3 with my sorted list still took a little while. Say takes 1 99 seconds to sort sorted list and now i'll zoom out here so we can see all of our numbers and now keep in mind that we don't care so much about the milliseconds it doesn't quite matter if it took 10 milliseconds here or 10 milliseconds there we care more about how each algorithm performed in the best and the worst case and we'll keep in mind what we know about our algorithms over here. If i look at this list it's generally pretty fast in both cases selection sort seems to be pretty slow in both cases both my reversed list and my sorted list bubble sort though seems to be slow in the worst case but actually pretty quick in the best case so let's take a look then at our numbers here if we look at sort two it seems like this is a very. This one was pretty quick in both cases it took less than a second to sort a sorted list and to sort a reversed list so knowing what we know about merge sort and how it performs in both best and worst cases maybe this one is probably merge sort so i'll say merge sort here now let's consider the other two i have this one sort one that took over like almost five seconds to sort as a reversed list. But then it took less than a second to sort a sorted list now knowing what we know about our algorithms which one does this seem to be seems likely to be bubble sort because we saw if i go back to our notations here that bubble sort was big of of a squared but big omega of a and a is certainly faster than a squared when it comes to these notations and now the final one we could say well by process of elimination it's probably going to be. Be selection sort but we could also say here well it took about two seconds to sort the reversed list and a still amount of time to sort the sorted list so maybe it's going to be in this case selection sort because we know based on our chart here that selection sort takes out the same amount of time in the best and the worst cases so i'll fix my typo here and now we have our mystery solved of which algorithms these sorts are using. So i'm going to go ahead and do that so i'm going to go ahead and do that and i'm going to go ahead and do that and i'm going to go ahead and do that and i'm going to go ahead and do that and i'm going to go ahead and do that and i'm going to go ahead and do that and i'm going to go ahead and do that and i'm going to go ahead and do that and i'm going to go ahead and do that and i'm going to go ahead and do that and i'm going to go ahead and do that and i'm going to go ahead and do that and i'm going to go ahead and do that and i'm going to go ahead and do that and i'm going to go ahead and do that and i'm going to go ahead and do that and i'm going to go ahead and do that and i'm going to go ahead and do that and i'm going to go ahead and do that and i'm going to go ahead and do that and i'm going to go ahead and do that and i'm going to go ahead and do that and i'm going to go ahead and do that and i'm going to go ahead and do that and i'm going to go ahead and do that and i'm going to go ahead and do that and i'm going to go ahead and do that and i'm going to go ahead and do that and i'm going to go ahead and do that and i'm going to go ahead and do that and i'm going to go ahead and do that and i'm going to go ahead and do that and i'm going to go ahead and do that and i'm going to go ahead and do that and i'm going to go ahead and do that and i'm going to go ahead and do that and i'm going to go ahead and do that and i'm going to go ahead and do that and i'm going to go ahead and do that and i'm going to go. Is helpful i think to write things like linear search like binary search things like bubble sort merge sort selection sort because in doing so you get an appreciation for exactly the process each one is following let's see a question here why is the reversed list faster than sorting the sorted list so if i look here for merge sort it seems like. This first case to sort the reversed list was faster than how long it took to sort the sorted list and that doesn't make any sense to me if i know that this is the worst case and this is supposed to be the best case well why is the best case slower than the worst case turns out when we're actually timing things in our computer there are other processes going on that could interfere with these things and make them take a little bit slower or a little bit faster depending on the time that i run them. And this is why computer scientists don't time things in terms of milliseconds they time things in terms of the number of steps their algorithm might actually take in the best and the worst cases so we don't have to consider here whether our computer is running some of their software just a single sort in this case of so that will be our recap then on our searching and sorting algorithms hopefully we've gotten a taste of big of notation and big omega notation let's start now adding another tool called the of notation. To our toolkit this one called struts so at the end of lecture early towards the middle i believe we learned about this idea of a structure and a structure is great we want to kind of create our very own data type to use in our program it's not quite a full data type but it is a way to encapsulate information so we can refer to it with only one name so let's take for instance this picture here we have two canons. For us government and i want to ask you what might you use to describe these candidates if you were going to store information about them what information would you store could be these two could be any candidate in any country for a political office i'm seeing maybe their age their party their name maybe the contact info directed to joe biden desk. Maybe the number of votes they got is a good one so there's lots of things to represent about this candidate and up until now we've been able to create individual variables that could store this information but a struck allows us to combine these pieces into a single one and refer to it all in general as some candidate so let's take an example here let's say in a we saw this syntax type def struck curly brace string name int votes. And curly brace candidate this looks a little confusing at first we can break it down to figure out what we're doing here so let's say first here we have some syntax to create a new quote unquote type it's not like a full type like an int is but does allow us to say we're going to consider name and votes part of some individual piece of data in our program and here is that full text here one other piece of syntax. Is this the type def this is kind of saying that we're going to take this combination of a string called name and an integer called votes and call it something else in this case a candidate so we could reuse this idea of a candidate throughout our file and then inside here we have what we call the members of the structure that is what kind of data are we going to encapsulate or consider to be part of what it means. To be a candidate so here we chose just the name and the number of votes for a candidate but you could very well have in this case their age their party and so on so all we're doing here is saying that these two pieces of data one a string we'll call name and one an integer we'll call votes are now part of this more general data type called a candidate and we can reuse that type throughout our program. Making our very own candidate so we'll go through here and say let's create a candidate called president let's create a candidate called president and we'll on the right hand side have this picture of a candidate here so see on the right hand side now if we want to give this candidate a name we could do so like this we could say president name equals whatever name we have for them. And now if we want to give them some number of votes we could say president votes now gets the value 10 so notice here on the line below our type def struck we're saying candidate space president so this looks a little similar to our prior syntax we were able to say maybe int a or string name but now we're using this name candidate as kind of a type name if you will for this new variable we created. And if i want to assign some value to the different members of president i could simply access them using the name dot the members name so president dot name president dot votes and so on and even further here i could try to create my very own array of candidates i could say in this case candidate candidates bracket four now to be clear here what i've done is i've created an array called candidate. It's plural that stores four elements but what elements will it store well in this case those that are candidates so you can see the type still comes first but then we have the name followed by brackets and the candidates here so questions then on the syntax of these arrays or these struts here is it possible to have a struck made out of other struts. Don't quite know i don't see why it wouldn't be the case that you couldn't do that yeah i would try it out and see i don't have as much experience to know about that you should definitely try it out and see let's see other questions here too question can we change the data in there if needed during run time so that's a good question if i go back to this candidate that we called president. Here the question is could i change the data inside of it later so to be clear i could assign different values to this candidates members like candidate name or candidate votes i could change those throughout my program but i really shouldn't be able to add new members to my struck as my program is running so up top here you'll see we defined a candidate as having a string called name and an integer called votes. I have to do that at the very start of my program i can't change that really while my program is running good question all right and a question here could we just use candidate name instead of president name like the structure name instead of the variable name we just created so it's worth mentioning here that the struck candidate is more so not a variable we just created. We've created but a template for one so every new candidate we create has to have its own name but it will all be kind of let's see inherited from this idea of a candidate so candidate president candidate vice president we could maybe have a candidate called candidate but we'd still have to instantiate that by saying candidate space candidate the type name then the variable name and probably in that case best not to. Views the variable name with the structure name so i would probably avoid that altogether of so let's get some practice with this and we'll have a task here which is to find a candidate who's gotten the most votes so what we'll do is first create an array of candidates and we'll search the array perhaps using linear search to find the most votes most awarded to any single candidate and then once we know that we'll print out the candidates name and our goal here is to get some practice. Practice using the syntax of struts so i'll go back to my code space and now pull up a file i've already created this one called let's see search a so i'll code search a to pull it up and notice how i already have some code in here so at the top i've included my cs50 library and my standard to library. I've defined for myself a struck that has a name and a votes member and i've called it candidate now down below in main i've created myself an array of candidates this has a total of three possible numbers i've defined this constant here a number that can't change and defined it as three so now i have three candidates that can go inside of this array down below i've defined their name and the number of votes. But now my goal is to find who has the highest number of votes or even before i do that before i find who has the highest number of votes i could probably find what the highest number of votes actually even is so the question really boils down to how could we use linear search to find this highest number of votes and now let me ask you what kind of structure would be good to search this array. If i wanted to loop through every candidate what kind of structure would be good maybe i'm seeing a for loop so i could do for and i know i want to go from let's say the very first candidate all the way to the final candidate so i'll start my index i at 0 and i'll say i'll keep going while i is less than well however many candidates i have which turns out to be no. Cum candidates which i defined up above right here so now i want to increase i by 1 each time that i go and now inside this loop what should i do my goal is to find the highest number of votes so maybe i should first make a variable that defines that number of votes for me i could say create an integer let's call it highest votes and we'll set it equal well at the beginning i don't quite know what it will be. Maybe it could be 0 to begin with so now we have this variable highest votes that's equal to 0 but now you have to ask under what scenario should i update highest votes as i loop through my candidates when should i try to update the highest votes let's say i look at carter first should i update highest votes. Seems like i should because carter has 10 votes and our previous highest was 0 so while i'm looping i could ask this question i could say if let's say candidates bracket i that is the candidate in my list at the index i if their number of votes candidates bracket i dot votes is greater than what we've currently said is the highest number of votes well. I want to update it so i'll say highest votes then becomes candidates bracket i dot votes so now what i've done is said that if i ever find a candidate who has a number of votes greater than my current highest number of votes i want to update what i'm considering to be the highest number of votes so let's walk through this one step by step so first highest votes. Is zero i'll look first at carter ten is greater than zero so our highest number of votes will now be ten i'll look at the next candidate this one is julia and i'll say well is twelve greater than ten it is so my new highest number of votes is now twelve i'll then look at no and i'll ask well is seven greater than twelve it's not in this case so my highest number of votes is still going to be twelve and by the time i'm done. Then highest votes should actually equal the number of votes that is the highest and to confirm this i could say print i for that integer format code and i'll print out now highest votes and let's try to make this program and compile it and see what happens so i'll go back to my terminal and i'll say make in this case search seems like no errors i'll run dot slash search. And i'll get back 12 for the candidate who has that highest number of votes of so that seems to accomplish my very first task finding the highest number of votes what can i do now to print the name of the candidate with that highest number of votes any ideas here i know the highest number i just want to see who has that number of votes. I should do is do another loop through my candidates array this time asking are you the person who has the highest are you the person who has the highest and if you are i'll print out your name as i go so let's try this i'll say for int i equals 0 again i is less than my number of candidates i plus plus i'm going to loop through every candidate here and i'll ask this question now if candidates bracket i dot votes the candidate at this index their number of votes if that is equal. To highest votes well then i want to print out their name so i'll say print and i'll do percent a for that string format code and now i'll use candidates bracket i dot name to get the name of this candidate so now what i've done is i've looped through my entire array asking this question does this candidate have the highest number of votes and if they do let me print out their name so now let me go back. Back and i make my program again i'll type make let's say make search and i'll run search and i'll see the highest number of votes is 12 and the candidate with that number of votes is now julia so our goal here was to see how we could use this structure syntax to simplify things for us like now i have this structure called candidate that i can use to my program and i can talk in the same breath. About a candidates name and the number of votes not keeping those two things separate they're part of that same structure i defined up top which really helped me out as i run my program here so questions then on struts a question about repeating code so in general it is true that you generally don't want to repeat code in your programs in this case though. I would argue we can't avoid repeating code here so if i'm first trying to find the highest number of votes and print out that persons name you might think i could do it all in the same loop but let's try this so i'll look first at my very first candidate whose name is carter and i'll see that carters votes for 10 well that's higher than what i've previously seen it's greater than 0 right but should i print carters name yet. As having the highest number of votes i probably shouldn't i need to keep looking through my list i need to confirm that there's no person with a higher number of votes than carter so that's why i need now two loops my first loop goes through and confirms what is the highest number of votes my second loop goes through and then confirms what will be their candidates name in that case. Other questions too let's see that seems to be covering most of the questions i'm seeing here of so let's keep going then and i think we have an idea of what struts are but i want to give you one more tool to use as you go off for this week and that is this tool called. Recursion so often recursion tends to be a very elegant solution to some problems and for that reason we have to try to find a way to use recursion to solve problems the caveat here is that it's not always the best way to do things but it can be elegant in certain cases and so we'll talk about the kinds of problems that are actually have a good potential to be solved with recursion now one problem like this this idea of a factorial so if you. Aren't familiar a factorial is simply a number where you take that number and multiply it by the number that's one less than it then that much one less than that and that much one less than that and so on so let's take a look at an example here if i want to find one factorial well that is just one and the factorial is this exclamation point here one factorial equals one but now if i want to find two factorial well two factorial is simply 2 times 1. So 2 times the number less than it 1 in this case well 3 factorial that is 3 times 2 times 1 so again start with that number 3 multiply it by the number 1 less than it then again then again so 3 times 2 times 1 and now 4 factorial what do you think that will be well 4 times 3 times 2 times 1 so in this case 1 factorial 1 2 factorial 2 3 factorial 6 and 4 factorial. Factorial about 24 in the end so what makes this problem good for a recursive solution well you might notice a bit of a pattern here it gets a little more obvious i do this with these numbers if i slide them over so what do you notice in particular about now 2 factorial it seems like to me that the solution. Solution for 1 factorial is part of the solution for 2 factorial that is if 1 factorial is 1 we could compute 2 factorial by taking 2 times 1 factorial and similarly for 3 factorial it looks like to me we could solve that problem by saying well 3 factorial is just 3 times 2 factorial and same thing with 4 we could say well 4 factorial is just 4 times 3 factorial. So we're able to find a solution to this problem in a smaller version of that problem until of course we get down to one factorial and we just say well that is just one in the end so to make these a little more concrete in computer science we might give a few names of these things so first we'll say four factorial is equal to what well four times three factorial but this here is what we're going to call our recursive call. Kind of kick the can as david said and say well we know the solution of four factorial is just four times three factorial now the question becomes what is three factorial let's find out let's take three factorial and let's find it well three factorial is just three times two factorial of well what's two factorial well it's two times one factorial well what is one factorial eventually it has to be some base case some definite solution to this problem in this case we say one factorial has. To be 1 and when we get to this base case we can use that to solve all prior problems in this case i could say i could substitute 1 factorial for 1 going back up the call stack so now we have 2 factorial is 2 times 1 3 factorial is 3 times 2 times 1 and 4 factorial is just 4 times 3 times 2 times 1 and typically here the vocabulary is that we're calling these functions again and again and again. And when we get to that base case we go back up what we call this call stack we're calling it a call stack because we're calling functions and they kind of stack on top of each other one at a time before we resolve everything all at once at the end so questions here on this recursive solution to factorials before we write our own implementation in a a question is recursion factorial. And. The answer to good question here of so let's now take the same idea and translate it into code so i'll go back to my code space here and i will get rid of search a and i will instead find factorial a so in the same way we already have some code here for us i have included the cs50 library. And standard i of now i have defined up here a function called factorial this is the prototype for that function so notice here it takes an integer called a as an input and it gives us back some integer in the end and that makes sense if i were to say give me 4 factorial i would give it some integer in this case 4 and i would get back some integer in the end in this case 24 so now in the main function i have a few components here. The first is to get the input from the user and it turns out that in factorial land you can't take a factorial of a negative number or at least we don't really want to do that here it gets kind of complicated so we're only going to focus on positive numbers we'll prompt the user again and again for a positive number and then finally we'll print the factorial of that number in this case we're going to print out our percent i format code a placeholder if you will but we'll substitute in the result of calling. The factorial function given in input from the user but now down below it seems like factorial isn't quite implemented here so if you think you have a solution to a problem that involves recursion it's often a good first step to ask yourself what is the base case what is the scenario i know the answer to and try to code that one first so my question to you then is. What is the answer that we know the answer to in this case we know the answer to if a is 1 so i could say if a equals 1 like this what do i return well i just return 1 it's a very simple solution right if a is 1 return 1 and now down below well i might actually first call this my base case here. Down below what is my recursive call if i go back to my template here we certainly have our base case now but what is our recursive call what should that look like well i know i could return let's say a but a times what a times well i could just call factorial again i could say return a times factorial. A minus 1 like this so now what i've done is i've added that recursive call if i call factorial given let's say 4 i won't activate my base case 4 is not 1 but i will go down here and say i'm going to calculate 4 times the factorial of 3 and i'll go back to running factorial again and again and again until i find that base case and return and return and return and return until i find my ultimate base case. Answer here so i'm going to prove you this works i go back to my terminal i'll say make factorial and then i'll say dot slash factorial and i'll give it in this case 4 and i get 24 i'll do it again i'll put in 3 and i'll get 6 i'll do it again i'll put in 2 and in this case i'll get 2 so now let's actually try to prove to you that this works. I will use debug50 which is what we saw in an earlier lecture and in debug50 i can actually step through my program step by step by step to show you what's happening underneath the hood as this program runs so i will say let's pause on line 17 right here and let's walk through each step one at a time to see what this recursive function is actually doing so i will go back to my terminal and i'll say debug50 slash factorial. We'll wait for things to load here it might take a minute or two but as things come into picture here notice a few different areas let me clean this up notice in particular my variables portion and my call stack so recall what a variable is simply some name that has some variable. Value and our call stack was some new vocabulary we just learned that is the idea of calling some function then calling another function and calling another one until we have the stack of function calls we need to resolve at the end so here i'll tell my program i'm going to give it an input of 3 in this case 3 like this so now i'm paused at this step in my program notice here on the variables tab that a is equal. Equal to 3 like we thought it would be now instead of stepping over this that is like completing this function and just printing the result let me step into this and try to figure out what's going on in this factorial function itself so i will choose in this case step into and notice how here i called factorial for the first time this is the first time i've called factorial a is equal to 3 up top now is a equal to 1. It's not so what our program will do is move on it will go down here and instead return a times factorial a minus 1 so let's step inside again and see what this next call to factorial is doing i'll step into and notice a few things change well a is now 2 but i've added one more step to my call stack before i can resolve this one i need to resolve this one right. So i'll keep going a is now 2 is that equal to 1 it's not we'll step over and now i'll say a times factorial a minus 1 i'm going to compute that next so 2 times factorial of 1 i'll step into this again and notice my call stack again so before i can resolve this first factorial call i have to resolve those that are on top of it the 1 for 2 and now the 1 for 1 so let's resolve this one. One here a equals one well seems like this is not going to be true so i'll step over and i'll now return one notice what happens here this call that we're currently on to factorial when we return one it'll go away and we'll just give back to this call here that value one so i will now step over step over again and now i'll see i've completed that call to factorial i was able to find that this call. Now two times one returning two times one this call can now return it knows that two factorial is two times one i'll return now this one knows well what is three factorial but three times two times one i'll return that and now i'm back up at main and completing my program as a whole so that is our step by step walk through of the recursive nature of factorial now it's okay if it didn't come. All at once and in fact i'd encourage you to do the same thing on your own computer or even get out some pencil and paper just like write stuff down and visualize as you go through and you'll hopefully see the recursive nature of it trying to solve a smaller problem and a smaller problem once you get that base case all the other problems become clearer as you go so questions then on this. Do the calls execute so you'll hear this more later in the course but there's this idea of a data structure called a stack and the key idea of a stack is that the last thing you put in is the first thing you do or that you see so in a call stack the last function i added was factorial that is then the first function i must resolve before i can do anything else so you could imagine here. Call factorial once if i call factorial for 3 i then end up calling factorial two more times overall but what i have to do first is resolve that very base case then i can resolve the 2 factorial then i can resolve the 3 factorial until finally i go back up here and resolve main as a whole i hope that helps a little bit i have a question now about the return 1 here so if i scroll down here we said return 1 for this. Factorial call and the question was why didn't it kill the entire program why didn't it end the entire program well notice how return here return ends my given function call so remember how we called factorial a total of three times that final time we called factorial we triggered our base case and simply returned one without making any new recursive calls and as soon as we did that we knew then how to resolve the other recursive calls that we tried to finish beforehand. And a clarifying question here is may an always resolve blast yes it is because it is our very first function we call when we run our program other questions here too all right so if there are no more questions i'm seeing here why don't we call that. A wrap for this weeks section certainly you've gotten a lot of new tools in your toolkit to solve problems which you certainly solved this weeks problem set i wish you all the best as you go through and finish this week and i'll hopefully see you next time thank you all for coming in