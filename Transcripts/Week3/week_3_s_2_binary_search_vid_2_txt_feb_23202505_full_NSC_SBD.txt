All right so binary search is an algorithm we can use to find an element inside of an array unlike linear search it requires a special condition be met beforehand but it's so much more efficient if that condition is in fact met so what's the idea here it's divide and conquer we want to reduce the size of the search area by half each time in order to find a target number this is where that condition comes into play though. Only leverage the power of eliminating half of the elements without even looking at them if the array is sorted if it's a complete mix up we can't just out of hand discard half of the elements because we don't know what we're discarding but if the array is sorted we can do that because we know that everything to the left of where we currently are must be lower than the value we're currently at and everything to the right of where we are must be greater than the value we're currently looking at so what's the pseudo code steps for binary search. Until the array or as we proceed through sub arrays smaller pieces of the original array is of size 0 calculate the midpoint of the current sub array if the value you're looking for is in that element of the array stop you found it that's great otherwise if the target is less than what's at the middle so if the value we're looking for is lower than what we see repeat this process again but change the endpoint instead of being the original complete full array to be just. To the left of where we just looked we knew that the middle was too high or the target was less than the middle and so it must exist if it exists at all in the array somewhere to the left of the midpoint and so we'll set the array location just to the left of the midpoint as the new endpoint conversely if the target is greater than what's at the middle we do the exact same process but instead we change the start point to be just to the right of the midpoint we just kept. And then we begin the process again let's visualize this of so there's a lot going on here but here's an array of 15 elements and we're going to be keeping track of a lot more stuff this time so in linear search we were just caring about a target but this time we want to care about where are we starting to look where are we stopping looking and what's the midpoint of the current array so here we go with binary search we're pretty much good to go right i'm just going to put down below here a set of indices this is basically just what elements are. Of the array we're talking about with linear search we care in as much as we need to know how many elements we're iterating over but we don't actually care what element we're currently looking at in binary search we do and so those are just there as a little guide so we can start right well not quite remember what i said about binary search we can't do it on an unsorted array or else we are not guaranteeing that certain elements or values aren't being accidentally discarded when we just decide to ignore half of the array. So step one with binary search is you must have a sorted array and you can use any of the sorting algorithms we've talked about to get you to that position so now we're in a position where we can perform binary search so let's repeat the process step by step and keep track of what's happening as we go so the first thing we need to do is calculate the midpoint of the current array we're going to say first of all we're looking for the value 19 we're trying to find the number 19 the first element of this array is located at index 0 and the last element of this array is located at index 14. Start and end so we calculate the midpoint by adding 0 plus 14 divided by 2 pretty straightforward midpoint and we can say that the midpoint is now 7 so is 15 what we're looking for no it's not we're looking for 19 but we know that 19 is greater than what we found at the middle so what we can do is change the start point to be just to the right of the midpoint and repeat the process again and when we do that we now say the new start point is a rate. What we've effectively done is ignored everything to the left of 15 we've eliminated half of the problem and now instead of having to search over 15 elements in our array we only have to search over 7 so 8 is the new start point 14 is still the end point and now we go over this again we calculate the new midpoint 8 plus 14 is 22 divided by 2 is 11 is this what we're looking for no it's not it's still the end point. We're looking for a value that's less than what we just found so we're going to repeat the process again we're going to change the end point to be just to the left of the midpoint so the new endpoint becomes 10 and now that's the only part of the array we have to sort through so we have now eliminated 12 of the 15 elements we know that if 19 exists in the array it must exist somewhere between element number 8 and element number 10 so we calculate the new midpoint again 8 plus 10. Is 18 divided by 2 is 9 and in this case look the target is at the middle we found exactly what we're looking for we can stop we've successfully completed a binary search all right so we know this algorithm works if the target is somewhere inside of the array does this algorithm work if the target is not in the array well let's start again and this time let's look for the element 16 which visually we can see does not exist anywhere in the array the start point is again 0 the end point is again 14 those are the indices of the first array. And last elements of the complete array and we'll go through the process we just went through again trying to find 16 even though visually we can already tell that it's not going to be there we just want to make sure that this algorithm will in fact still work in some way and not just leave us stuck in an infinite loop so what's the step first calculate the midpoint of the current array what's the midpoint of the current array well it's 7 right 14 plus 0 divided by 2 is 7 is 15 what we're looking for no. But we're looking for a value slightly bigger than that so we know that it's going to be nowhere to the left of 15 the target is greater than what's in the midpoint and so we set the new start point to be just to the right of the middle the midpoint is currently seven so let's say the new start point is eight and what we've effectively done again is ignore the entire left half of the array now we repeat the process one more time calculate the new midpoint 8 plus 14 is 22 divided by 2 is 11 it's 23. Unfortunately no we're looking for a value that is less than 23 and so in this case we're going to change the endpoint to be just to the left of the current midpoint the current midpoint is 11 and so we'll set the new endpoint for the next time we go through this process to 10 again we go through the process again calculate the midpoint 8 plus 10 divided by 2 is 9 is 19 what we're looking for unfortunately no we're still looking for a number less than that so we'll change the endpoint this time. To be just to the left of the midpoint the midpoint is currently 9 so the endpoint will be 8 and now we're just looking at a single element array what's the midpoint of this array well it starts at 8 it ends at 8 the midpoint is 8 is that what we're looking for we're looking for 17 now we're looking for 16 so if it exists in the array it must exist somewhere to the left of where we currently are so what we're going to do well we'll set the endpoint to be just to the left of the current midpoint so we'll change the endpoint to 7. So let's see what just happened here though look up here now start is now greater than end effectively the two ends of our array have crossed and the start point is now after the endpoint well that doesn't make any sense right so now what we can say is we have a sub array of size 0 and once we've gotten to this point we can now guarantee that the element 16 does not exist in the array because the start point and endpoint have crossed and so it's not there. Different than the start point and end point being the same if we had been looking for 17 it would have been in the array and the start point and end point of that last iteration before those points crossed we would have found 17 there it's only when they cross that we can guarantee that the element does not exist in the array so this took a lot fewer steps than linear search in the worst case scenario we had to split up a list of a elements repeatedly in half to find the target either because the target element will be somewhere in the last divider. Or it doesn't exist at all so in the worst case we have to split up the array log of a times we have to cut the problem in half a certain number of times that number of times is log a what's the best case scenario well the first time we calculate the midpoint we find what we're looking for in all of the previous examples on binary search we've just gone over if we had been looking for the element 15 we would have found that immediately that was at the very beginning that was the midpoint of the first attempt. Attempt at a split of a division in binary search and so in the worst case binary search runs in log a which is substantially better than linear search in the worst case in the best case binary search runs in omega of 1 so binary search is a lot better than linear search but you have to deal with the process of sorting your array first before you can leverage the power of binary search i'm doug lloyd this is cs50. You