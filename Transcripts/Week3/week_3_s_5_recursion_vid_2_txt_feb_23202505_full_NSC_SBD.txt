You probably think that code is just used to accomplish a task you write it out it does something and that's pretty much it you compile it you run the program you're good to go but believe it or not if you code for a long time you actually might come to see code as something that's beautiful it solves a problem in a very interesting way or there's just something really neat about the way it looks you might be laughing at me but it's true and recursion is one way. To sort of get this idea of beautiful elegant looking code it solves problems in ways that are interesting easy to visualize and surprisingly short the way recursion works is a recursive function is defined as a function that calls itself as part of its execution that might seem a little strange and we'll see a little bit about how this works in a moment but again these recursive procedures are going to be so elegant because they're going to solve this problem without having all these other. Functions or these long loops you'll see that these recursive procedures are going to look so short and they really are going to make your code look a lot more beautiful let's look at an example of this to see how a recursive procedure might be defined so if you're familiar with this from match class many years ago there's something called the factorial function which is usually denoted as a exclamation point which is defined over all positive integers and the way that a factorial is calculated is you multiply. All of the numbers less than or equal to a together all the integers less than or equal to a together so 5 factorial is 5 times 4 times 3 times 2 times 1 and 4 factorial is 4 times 3 times 2 times 1 and so on you get the idea as programmers we don't use a exclamation points so we'll define the factorial function as fact of a and we'll use factorial to create a recursive solution to a problem and i think you might find that it's a lot more visually appealing. Than the iterative version of this which we'll also take a look at in a moment so here are a couple of facts pun intended about factorial the factorial functions the factorial of 1 as i said is 1 the factorial of 2 is 2 times 1 the factorial of 3 is 3 times 2 times 1 and so on we talked about 4 and 5 already but looking at this isn't this true isn't factorial of 2 just 2 times the factorial of 1 i mean the factorial of 1 is 1. So why can't we just say that since factorial of 2 is 2 times 1 it's really just 2 times the factorial of 1 and then extending that idea isn't the factorial of 3 just 3 times the factorial of 2 and the factorial of 4 is 4 times the factorial of 3 and so on in fact the factorial of any number can just be expressed if we kind of carry this out forever we can kind of generalize the factorial problem as it's a times the factorial of a minus 1. And it's a times the product of all the numbers less than me this idea this generalization of the problem allows us to recursively define the factorial function when you define a function recursively there's two things that need to be a part of it you need to have something called a base case which when you trigger it will stop the recursive process otherwise a function that calls itself as you might imagine could go on forever function calls the function calls the function calls the function calls the function. If you don't have a way to stop it your program will be effectively stuck at an infinite loop it will crash eventually because it will run out of memory but that's beside the point we need to have some other way to stop things besides our program crashing because a program that crashes is probably not beautiful or elegant and so we call this the base case this is a simple solution to a problem which stops the recursive process from occurring so that's one part of the recursive function the second part is the recursive case and this is where the recursion will actually take place. Will call itself it won't call itself in exactly the same way it was called it'll be a slight variation that makes the problem it's trying to solve a teeny bit smaller but it generally passes the buck of solving the bulk of the solution to a different call down the line which of these looks like the base case here which one of these looks like the simplest solution to a problem we have a bunch of factorials that we can continue going on 6 7 8 9 10 and so on. But one of these looks like a good case to be the base case it's a very simple solution we don't have to do anything special the factorial of 1 is just 1 we don't have to do any multiplication at all it seems like if we're going to try and solve this problem and we need to stop the recursion somewhere we probably want to stop it when we get to 1 we don't want to stop before that so if we're defining our factorial function and here's a skeleton for how we might do that we need to plug in those two things. The base case and the recursive case well what's the base case if a is equal to 1 return 1 that's a really simple problem to solve right the factorial of 1 is 1 it's not 1 times anything it's just 1 it's a very easy fact and so that can be our base case if we get past 1 into this function we'll just return 1 what's the recursive case probably look like for every other number besides 1. What's the pattern well if we're taking the factorial of a it's a times the factorial of a minus 1 if we're taking the factorial of 3 it's 3 times the factorial of 3 minus 1 or 2 and so if we're not looking at 1 otherwise return a times the factorial of a minus 1 it's pretty straightforward right and for the sake of having slightly cleaner and more elegant code know that if we have single line loops or single line loops. Line conditional branches we can get rid of all of the curly braces around them so we can consolidate this to this this has exactly the same functionality as this i'm just taking away the curly braces because there's only one line inside of those conditional branches so these behave identically if a is equal to 1 return 1 otherwise return a times the factorial of a minus 1 so we're making the problem smaller. And it starts out as 5 we're going to return 5 times the factorial of 4 and then we'll see in a minute when we talk about the call stack or in another video when we talk about the call stack we'll learn about why exactly this process works but while factorial of 5 says return 5 times factorial of 4 then 4 is going to say of we'll return 4 times the factorial of 3 and as you can see we're sort of approaching 1 we're getting closer and closer to that base case and once we hit the base case all of the previous functions have the answer they were looking for. Factorial of 2 was saying return 2 times the factorial of 1 well factorial of 1 returns 1 so the call for factorial of 2 can return 2 times 1 and give that back to factorial of 3 which is waiting for that result and then it can calculate its result 3 times 2 is 6 and give it back to factorial of 4 and again we have a video on the call stack where this is illustrated a little more than what i'm just saying right now but this is it this alone is the solution to calculating the factorial of a number. More lines of code that's pretty cool right and it's kind of sexy so in general but not always a recursive function can replace a loop in a non recursive function so here side by side is the iterative version of the factorial function both of these calculate exactly the same thing they both calculate the factorial of a the version on the left uses recursion to do it the version on the right uses iteration to do it and notice we have to declare a variable. An integer product and then we loop so long as a is greater than 0 we keep multiplying that product by a and decrementing a until we calculate the product so these two functions again do exactly the same thing but they don't do it in exactly the same way now it is possible to have more than one base case or more than one recursive case depending on what your function is trying to do you're not necessarily just limited to a set. Single base case or a single recursive case so an example of something with multiple base cases might be this the fibonacci number sequence you may recall from elementary school days that the fibonacci sequence is defined like this the first element is 0 the second element is 1 both of those are just by definition then every other element is defined as the sum of a minus 1 and a minus 2 so the third element would be 0 plus 1 is 1. And then the fourth element would be the second element 1 plus the third element 1 and that would be 2 and so on and so on so in this case we have two base cases if a is equal to 1 return 0 if a is equal to 2 return 1 otherwise return fibonacci of a minus 1 plus fibonacci of a minus 2 so that's multiple base cases what about multiple recursive cases. Called the coat conjecture and i'm not just going to say you know what that is because it's actually our final problem for this particular video and it's our exercise to work on together so here's what the coat conjecture is it applies to every positive integer and it speculates that it's always possible to get back to 1 if you follow these steps if a is 1 stop we've got back to 1 if a is 1. Otherwise go through this process again on a divided by 2 and see if you can get back to 1 otherwise if a is odd go through this process again on 3n plus 1 or 3 times a plus 1 so here we have a single base case if a is equal to 1 stop we're not doing any more recursion but we have two recursive cases if a is even we do one recursive case calling a divided by 2. We do a different recursive case on 3 times a plus 1 and so the goal for this video is to take a second pause the video and try and write this recursive function coats where you pass in a value a and it calculates how many steps it takes to get to 1 if you start from a and you follow those steps up above if a is 1 it takes 0 steps right otherwise it's going to take one step plus 1. However many steps it takes on either a divided by 2 if a is even or 3n plus 1 if a is odd now i've put up on the screen here a couple of test things for you and a couple of test cases for you to see what these various coats numbers are and also an illustration of the steps that need to be gone through so you can sort of see this process in action so if a is equal to 1 coats of a is 0 you don't have to do anything to get back to 1 you're already there if a is 2 it takes 1 step. To get to 1 you start with 2 well 2 is not equal to 1 so it's going to be 1 step plus however many steps it takes on a divided by 2 a divided by 2 2 divided by 2 is 1 so it takes 1 step plus however many steps it takes for 1 1 takes 0 steps for 3 as you can see there's quite a few steps involved you go from 3 and then you go to 10 5 16 8 4 2 1 it takes 7 steps to get back to 1. You can see there's a couple other test cases here to test out your program so again pause the video and i'll go jump back now to what the actual process is here what this conjecture is see if you can figure out how to define coats of a so that it calculates how many steps it takes to get to 1 so hopefully you have paused the video and you aren't just waiting for me to give you the answer here but if you are well here's the answer anyway so here is the possible definition. Of the coats function our base case if a is equal to 1 we return 0 it doesn't take any steps to get back to 1 otherwise we have two recursive cases one for even numbers and one for odd the way i test for even numbers is to check if a mod 2 equals 0 this is basically again asking the question if you recall what mod is is if i divide a by 2 is there no remainder that would be an even number and so if a mod 2 equals 0 is testing is this an even number. If so i want to return 1 because this is definitely taking me one step plus coats of whatever number is half of me otherwise i want to return 1 plus coats of 3 times a plus 1 that was the other recursive step that we could take to calculate the number of steps it takes to get back to 1 given a number so hopefully this example gave you a little bit of a taste of recursive procedures hopefully you think code is a little more beautiful if implemented in an elegant way. Recursive way but even if not recursion is a really powerful tool nonetheless and so it's definitely something to get your head around because you'll be able to create pretty cool programs using recursion that might otherwise be complex to write if you're using loops in iteration i'm doug lloyd this is cs50