Hi i'm carrie anne and this is crash course computer science. Cup will perform a different task so the cup is a piece of hardware controlled by easy to modify software let's quickly revisit the simple program we stepped through last episode the computer memory looked like this each address contained 8 bits of data for a hypothetical cup the first 4 bits specified the operation code or opcode and the second set of 4 bits specified an address. Or registers in memory address 0 we have 00101110 again those first four bits are our opcode which corresponds to a load a instruction this instruction reads data from a location of memory specified in those last four bits of the instruction and saves it into register a in this case 1110 or 14 in decimal so let's not think of this memory address 0 as 00101110 but rather as the instruction loada14 that's much easier to read. And understand and for me to say and we can do the same thing for the rest of the data in memory in this case our program is just four instructions long and we've put some numbers into memory 2 3 and 14 so now let's step through this program first is load a14 which takes the value in address 14 which is the number 3 and stores it into register a then we have a load b15 instruction which takes the value in memory location 15 which was the number 14 and saves it into register a okay easy enough but now we have an add instruction. This tells the processor to use the all to add two registers together in this case a and a are specified the ordering is important because the resulting sum is saved into the second register that's specified so in this case the resulting sum is saved into register a and finally our last instruction is store a13 which instructs the cup to write whatever value is in register a into memory location 13 yes our program adds two numbers together that's about as exciting as it gets when we only have four instructions to play with. So let's add some more now we've got a subtract function which like add specifies two registers to operate on we've also got a fancy new instruction called jump as the name implies this causes the program to jump to a new location this is useful if you want to change the order or skip some instructions for example a jump zero would cause the program to go back to the beginning at a low level this is done by writing the value specified in the last four bits into the instruction address register overwriting the current value we've also added a special version of jump called jump negative. This only jumps the program if the alums negative flag is set to true as we talked about in episode 5 the negative flag is only set when the result of an arithmetic operation is negative if the result was zero or positive the negative flag would not be set so the jump negative wouldn't jump anywhere and the cup would just continue on to the next instruction and finally computers need to be told when to stop processing so we need a halt instruction our previous program really should have looked like this to be correct otherwise the cup would have just continued on after the start. So let's make our program a bit more interesting by adding a jump we'll also modify our two starting values in memory to 1 and 1 let's step through this program just as our cup would. The value 1 into register a next load b15 loads the value 1 into register a as before we add registers a and a together with the sum going into register a 1 plus 1 equals 2 so now register a has the value 2 in it stored in binary of course then the store instruction saves that into memory location 13 now we hit a jump2 instruction this causes the processor to overwrite the value in the instruction address register which is currently 4 with the new value 2 on the processors next fetch cycle we don't fetch halt. Instead we fetch the instruction at memory location 2 which is add a we've jumped register a contains the value 2 and register a contains the value 1 so 1 plus 2 equals 3 so now register a has the value 3 we store that into memory and we've hit the jump again back to add a 1 plus 3 equals 4 so now register a has the value 4 see what's happening here every loop we're adding 1 is counting up cool but notice there's no way to ever escape we're never ever going to hit that halt instruction. Because we're always going to hit that jump this is called an infinite loop a program that runs forever ever ever ever ever to break the loop we need a conditional jump a jump that only happens if a certain condition is met our jump negative is one example of a conditional jump but computers have other types too like jump if equal and jump if greater so let's make our code a little fancier and step through it just like before the program starts by loading values from memory into registers a and a in this example the number of. So number 11 gets loaded into register a and 5 gets loaded into register a now we subtract register a from register a that's 11 minus 5 which is 6 and so 6 gets saved into register a now we hit our jump negative the last all result was 6 that's a positive number so the negative flag is false that means the processor does not jump so we continue on to the next instruction which is jump 2 no conditional on this one so we jump to instruction 2 no matter what of so we're back at our subtract register a from register a. So 1 gets saved into register a next instruction we're back again at our jump negative 1 is also a positive number so the cup continues on to the jump 2 looping back around again to the subtract instruction this time is different though 1 minus 5 is negative 4 and so the all sets its negative flag to true for the first time now when we advance to the next instruction jump negative 5 the cup executes the jump to memory location 5 we're out of the infinite loop now we have an. Add a to a negative 4 plus 5 is positive 1 and we save that into register a next we have a store instruction that saves register a into memory address 13 lastly we hit our hort instruction and the computer rests so even though this program is only 7 instructions long the cup ended up executing 13 instructions and that's because it looped twice internally this code calculated the remainder if we divide 5 into 11 which is 1 with a few extra lines of code we could also keep track of how many loops we did. The count of which would be how many times 5 went into 11 we did two loops so that means 5 goes into 11 two times with a remainder of 1 and of course this code could work for any two numbers which we can just change in memory to whatever we want 7 and 81 18 and 54 it doesn't matter that's the power of software software also allowed us to do something our hardware could not remember our all didn't have the functionality to divide two numbers instead it's the program we made that gave us that functionality and then other programs can use it. Use our divide program to do even fancier things and you know what that means new levels of abstraction so our hypothetical cup is very basic all of its instructions are 8 bits long with the opcode occupying only the first 4 bits so even if we used every combination of 4 bits our cup would only be able to support a maximum of 16 different instructions on top of that several of our instructions used the last 4 bits. To specify a memory location but again 4 bits can only encode 16 different values meaning we can address a maximum of 16 memory locations that's not a lot to work with for example we couldn't even jump to location 17 because we literally can't fit the number 17 into 4 bits for this reason real modern cups use two strategies the most straightforward approach is just to have bigger instructions with more bits like 32 or 64 bits this is called the instruction length unsurprisingly. To. Our example cup and instruction set is hypothetical designed to illustrate key working principles so i want to leave you with a real cup example in 1971 intel released the 4004 processor it was the first cup placed in a single chip and paved the path to the intel processors we know and love today it supported the 46 instructions shown here which was enough to build an entire working computer and it used many of the instructions we've talked about like jump add subtract and load it also uses 8 bit immediate values like we just talked. About for things like jumps in order to address more memory and processors have come a long way since 1971 a modern computer processor like an intel core i7 has thousands of different instructions and instruction variants ranging from 1 to 15 bytes long for example there's over a dozen different opcodes just for variants of add and this huge growth in instruction set size is due in large part to extra bells and whistles that have been added to processor designs over time which we'll talk about more next episode see you next week. Science is produced in association with pcs digital studios at their channel you can check out a playlist of shows like physics girl deep look and pcs space time this episode was filmed at the chad and stacey ever gold studio in indianapolis indiana and it was made with the help of all these nice people and our wonderful graphics team thought cafe that's where we're gonna have to halt and catch fire see you next week. You