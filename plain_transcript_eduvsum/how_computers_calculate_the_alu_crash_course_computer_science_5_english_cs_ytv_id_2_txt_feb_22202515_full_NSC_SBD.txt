Hi i'm carrie anne and this is crash course computer science so last episode we talked about how numbers can be represented in binary like 00101010 is 42 in decimal representing and storing numbers is an important function of a computer but the real goal is computation or manipulating numbers in a structured and purposeful way like adding two numbers together these operations are handled by a computers arithmetic logic unit but most people call it by its street name the all. All is the mathematical brain of a computer when you understand an alums design and function you'll understand a fundamental part of modern computers it is the thing that does all of the computation in a computer so basically everything uses it first though look at this beauty this is perhaps the most famous all ever the intel 74181 when it was released in 1970 it was the first complete all that fit entirely inside a single chip which was a huge engineering feat at the time. Today we're going to take those boolean logic gates we learned about last week to build a simple all circuit with much of the same functionality as that 74181 and over the next few episodes we'll use this to construct a computer from scratch so it's going to get a little bit complicated but i think you guys can handle it an all is really two units in one there's an arithmetic unit and a logic unit. Let's start with the arithmetic unit which is responsible for handling all numerical operations in a computer like addition and subtraction it also does a bunch of other simple things like add one to a number which is called an increment operation but we'll talk about those later today we're going to focus on the piece de resistance the creme de de creme of operations that underlines almost everything else a computer does adding two numbers together we could build this circuit entirely out of individual transistors but that would get confusing really fast so instead as we talked about in episode 3. We can use a high level of abstraction and build our components out of logic gates in this case and or not and xor gates the simplest adding circuit that we can build takes two binary digits and adds them together so we have two inputs a and a and one output which is the sum of those two digits just to clarify a a and the output are all single bits there are only four possible input combinations the first three are 0 plus 0 equals 0 1 plus 0 equals 1 and 0 plus 1. Remember that in binary 1 is the same as true and 0 is the same as false so this set of inputs exactly matches the boolean logic of an xor gate and we can use it as our 1 bit adder but the fourth input combination 1 plus 1 is a special case 1 plus 1 is 2 obviously but there's no 2 digit in binary so as we talked about last episode the result is 0 and the 1 is carried to the next column so the sum is really 1 0 in binary now the output of our xor gate is partially correct 1 plus 1 output 0. But we need an extra output wire for that carry bit the carry bit is only true when the inputs are 1 and 1 because that's the only time when the result is bigger than one bit can store and conveniently we have a gate for that an and gate which is only true when both inputs are true so we'll add that to our circuit too and that's it this circuit is called a half adder it's not that complicated just two logic gates but let's abstract away even this level of detail and encapsulate our newly minted half adder as its own component with two inputs bits a and a. And two outputs the sum and the carry bits this takes us to another level of abstraction i feel like i say that a lot i wonder if this is going to become a thing anyway if you want to add more than one plus one we're going to need a full adder that half adder left us with a carry bit as output that means that when we move on to the next column in a multi column addition and every column after that we're going to have to add three bits together not two a full adder is a bit more. Complicated it takes 3 bits as inputs a a and a so the maximum possible input is 1 plus 1 plus 1 which equals 1 carry out 1 so we still only need 2 output wires sum and carry we can build a full adder using half adders to do this we use a half adder to add a plus a just like before but then feed that result and input a into a second half adder lastly we need an or gate to check if either one of the carry bits was true that's it we just made a full adder. We can go up a level of abstraction and wrap up this full adder as its own component it takes three inputs adds them and outputs the sum and the carry if there is one armed with our new components we can now build a circuit that takes two 8 bit numbers let's call them a and a and adds them together let's start with the very first bit of a and a which we'll call a0 and b0 at this point there is no carry bit to deal with because this is our first addition so we can use our half adder to add those two bits together the output is sum 0. B1 together it's possible there was a carry from the previous addition of a0 and b0 so this time we need to use a full adder that also inputs the carry bit we output this result as sum1 then we take any carry from this full adder and run it into the next full adder that handles a2 and b2 and we just keep doing this in a big chain until all 8 bits have been added notice how the carry bits ripple forward to each subsequent adder for this reason this is called an 8 bit ripple carry adder. Carry out if there is a carry into the ninth bit it means the sum of the two numbers is too large to fit into eight bits this is called an overflow in general an overflow occurs when the result of an addition is too large to be represented by the number of bits you are using this can usually cause errors and unexpected behavior famously the original pc man arcade game used eight bits to keep track of what level you were on this meant that if you made it past level 255 the largest number store able in eight bits to level 256 the all overflowed this caused a bunch of errors and glitches. Making the level unbeatable the bug became a rite of passage for the greatest pc man players so if we want to avoid overflows we can extend our circuit with more full adders allowing us to add 16 or 32 bit numbers this makes overflows less likely to happen but at the expense of more gates an additional downside is that it takes a little bit of time for each of the carries to ripple forward admittedly not very much time electrons move pretty fast so we're talking about billionths of a second but that's enough to make a difference in today is fast computers. And modern computers use a slightly different adding circuit called a carry look ahead adder which is faster but ultimately does exactly the same thing adds binary numbers the alums arithmetic unit also has circuits for other map operations and in general these eight operations are always supported and like our adder these other operations are built from individual logic gates interestingly you may have noticed that there are no multiply and divide operations that's because simple plus don't have a circuit for this and instead just perform a series of additions. You want to multiply 12 by 5 that's the same thing as adding 12 to itself five times so it would take five passes through the all to do this one multiplication and this is how many simple processors like those in your thermostat to remote and microwave do multiplication it's slow but it gets the job done however fancier processors like those in your laptop or smartphone have arithmetic units with dedicated circuits for multiplication and as you might expect the circuit is more complicated than addition there's no magic it just takes a lot more logic gates. Which is why less expensive processors don't have this feature okay let's move on to the other half of the all the logic unit instead of arithmetic operations the logic unit performs well logical operations like and or and not which we've talked about previously it also performs simple numerical tests like checking if a number is negative. Final knot gate to flip this input so the output is 1 only if the input number is 0 so that's a high level overview of what makes up an all we even built several of the main components from scratch like our ripple adder as you saw it's just a big bunch of logic gates connected in clever ways which brings us back to that all you admired so much at the beginning of the episode the intel 74181 unlike the 8 bit all we made today the 74181 could only handle 4 bit inputs which means you built an all that's like twice as good. And how good is that super famous one with your mind well sort of we didn't build the whole thing but you get the idea the 74181 used about 70 logic gates and it couldn't multiply or divide but it was a huge step forward in miniaturization opening the doors to more capable and less expensive computers this 4 bit all circuit is already a lot to take in but our 8 bit all would require hundreds of logic gates to fully build and engineers didn't want to see all that complexity when using an all. Wrap it all up which looks like a big a just another level of abstraction our 8 bit all has two inputs a and beach with 8 bits we also need a way to specify what operation the all should perform for example addition or subtraction for that we use a 4 bit operation code we'll talk more about this in a later episode but in brief 1000 might be the command to add while 1100 is the command for subtraction. Basically the operation code tells the all what operation to perform and the result of that operation on inputs a and a is an 8 bit output plus also output a series of flags which are 1 bit outputs for particular states and statuses for example if we subtract two numbers and the result is zero our zero testing circuit the one we made earlier sets the zero flag to true this is useful if we are trying to determine if two numbers are equal if we wanted to test if a was less than a we can use the all to calculate a supported. Track a and look to see if the negative flag was set to true if it was we know that a was smaller than a and finally there's also a wire attached to the carryout on the adder we built so if there is an overflow we'll know about it this is called the overflow flag. 2 episodes from now but before that our computer is going to need some memory we'll talk about that next week. You